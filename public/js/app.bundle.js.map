{"version":3,"sources":["webpack:///./requires.js","webpack:///./scripts/controllers/mainCtrl.js","webpack:///./scripts/directives/ngMenus.js","webpack:///./scripts/services/authService.js","webpack:///./scripts/services/dataService.js","webpack:///./css/font-awesome.min.css","webpack:///./css/main.css","webpack:///../~/bootstrap/dist/css/bootstrap.css","webpack:///../~/textangular/dist/textAngular.css","webpack:///../~/textangular/dist/textAngular-sanitize.min.js","webpack:///../~/textangular/dist/textAngular.min.js","webpack:///./app.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wB;;;;;;;ACbA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8C;;AAEA;AACA;;AAEA;;;;AAIA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;;;AAG1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE,E;;AAEF;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;AAQA,CAAC,E;;;;;;AC3JD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;ACnBD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,CAAC,E;;;;;;ACdD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,CAAC,E;;;;;;;;;;;;;;;;;;;;ACdD,yC;;;;;;ACAA,yC;;;;;;ACAA,yC;;;;;;ACAA,yC;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uCAAuC;AAC/C;AACA;AACA;AACA;AACA;AACA;AA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ACA;AACA,wBAAwB,yBAAyB,QAAQ,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,+DAA+D,wEAAwE,KAAK,qBAAqB,qBAAqB,cAAc,gBAAgB,gBAAgB,8FAA8F,6BAA6B,eAAe,uBAAuB,aAAa;AAClZ;AACA;AACA;AACA,6HAA6H,2BAA2B,GAAG,wB;;;;;;ACjU3J,+EAAe;AACf;AACA,gIAAoF,oCAAoC;AAAA;AACxH;AACA;AACA;AACA,0GAA0G;AAC1G;AACA,cAAc,IAAI,qCAAqC,SAAS,UAAU;AAC1E;AACA;AACA;AACA;AACA,kHAAkH;AAClH,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6GAA6G,sMAAsM;AACnU;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oCAAoC,cAAc,qCAAqC;AACrG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI,yDAAyD,cAAc,EAAE,EAAE;AAC/E,IAAI,yDAAyD,cAAc,EAAE,EAAE;AAC/E;AACA;AACA,6TAA6T,wMAAwM,uBAAuB,GAAG,WAAW;AAC1iB;AACA,6BAA6B;AAC7B;AACA,8BAA8B;AAC9B,cAAc,qBAAqB,4DAA4D,4CAA4C,yBAAyB;AACpK;AACA;AACA,yEAAyE;AACzE;AACA,8BAA8B,uBAAuB,4DAA4D;AA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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG;AAClG;AACA;AACA,mGAAmG;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAsE,UAAU,4IAA4I,uCAAuC,iCAAiC,WAAW,8CAA8C,uBAAuB,oBAAoB;AACja;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO,uCAAuC;AAC7F;AACA,kCAAkC,0CAA0C,OAAO,qFAAqF,qGAAqG,MAAM,EAAE,uCAAuC,2CAA2C,6CAA6C,uBAAuB,8FAA8F;AACzgB;AACA,kDAAkD;AAClD,2CAA2C,EAAE;AAC7C;AACA,4DAA4D,wBAAwB;AACpF;AACA;AACA;AACA,sCAAsC;AACtC;AACA,wDAAwD;AACxD;AACA,oDAAoD;AACpD;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE,qBAAqB,iBAAiB,IAAI,SAAS,SAAS,oBAAoB,YAAY,WAAW,qBAAqB,kBAAkB;AACpK;AACA;AACA,yEAAyE;AACzE,+BAA+B;AAC/B,8KAA8K;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+BAA+B;AAC3E;AACA;AACA,qLAAqL,KAAK,EAAE;AAC5L;AACA;AACA,+BAA+B,KAAK,MAAM,6GAA6G,0BAA0B,OAAO;AACxL;AACA,qBAAqB;AACrB,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mJAAmJ;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA,8BAA8B,yBAAyB,wBAAwB;AAC/E;AACA;AACA,sCAAsC,wBAAwB,qBAAqB;AACnF;AACA,mKAAmK;AACnK;AACA;AACA,gCAAgC,YAAY,EAAE,+LAA+L,OAAO,2BAA2B;AAC/Q;AACA;AACA,+EAA+E,4CAA4C,sBAAsB,aAAa,WAAW,OAAO;AAChL;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA,kFAAkF,SAAS;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA,sJAAsJ,cAAc,qJAAqJ,slBAAslB;AAC/4B;AACA,8PAA8P;AAC9P;AACA,oDAAoD;AACpD,iCAAiC;AACjC;AACA,wEAAwE,OAAO;AAC/E;AACA;AACA;AACA;AACA,kBAAkB,SAAS,2BAA2B,IAAI,kDAAkD,SAAS;AACrH,SAAS,wCAAwC,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA,qKAAqK,sBAAsB,8CAA8C,qBAAqB;AAC9P;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,aAAa,wDAAwD,4HAA4H,gBAAgB,EAAE;AACnN,gCAAgC,wBAAwB,6BAA6B;AACrF;AACA;AACA;AACA,wWAAwW,kOAAkO,0IAA0I,0BAA0B,0QAA0Q;AACx/B;AACA,0IAA0I,2CAA2C;AACrL;AACA;AACA,2DAA2D,kCAAkC;AAC7F;AACA,kCAAkC,8DAA8D,0HAA0H,yEAAyE;AACnS,gCAAgC,qBAAqB,cAAc,OAAO,2FAA2F,kJAAkJ,qCAAqC,cAAc;AAC1W;AACA,OAAO,6EAA6E,2FAA2F,MAAM,cAAc,oCAAoC,yBAAyB;AAChQ;AACA,0BAA0B,8CAA8C;AACxE;AACA;AACA;AACA;AACA,oBAAoB,8CAA8C,MAAM,yCAAyC,4JAA4J,sBAAsB,EAAE;AACrS,+BAA+B,8GAA8G;AAC7I;AACA,6HAA6H,8HAA8H,+BAA+B,gIAAgI,uCAAuC,qBAAqB;AACtd;AACA;AACA;AACA,6rBAA6rB,yFAAyF,2CAA2C,+BAA+B,QAAQ,EAAE;AAC12B;AACA;AACA;AACA,oLAAoL,oBAAoB;AACxM;AACA;AACA,oBAAoB;AACpB;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,8QAA8Q,0BAA0B,wBAAwB;AAChU;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB,IAAI,yFAAyF;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA,qLAAqL,mEAAmE,2BAA2B,uHAAuH,4BAA4B;AACta;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA,+CAA+C,yBAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mHAAmH;AACnH;AACA;AACA;AACA;AACA,mHAAmH,MAAM,YAAY,SAAS,qBAAqB;AACnK;AACA;AACA;AACA,iCAAiC;AACjC;AACA,mBAAmB;AACnB;AACA,wBAAwB;AACxB;AACA,0DAA0D,WAAW,2BAA2B,EAAE;AAClG;AACA,4CAA4C;AAC5C;AACA,8BAA8B,4FAA4F,iFAAiF,KAAK;AAChN;AACA,ogBAAogB,4BAA4B,wLAAwL;AACxtB;AACA,wCAAwC,6EAA6E;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;A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","file":"app.bundle.js","sourcesContent":["/*Bootstrap*/\nrequire('jquery');\nrequire('bootstrap');\nrequire('bootstrap/dist/css/bootstrap.css');\n\n/*Text Angular*/\nrequire('textangular/dist/textAngular.css');\nrequire('textangular/dist/textAngular-sanitize.min.js');\nrequire('textangular/dist/textAngular.min.js');\n\n/*Font Awesome*/\nrequire('./css/font-awesome.min.css');\n\n/*CSS*/\nrequire('./css/main.css');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./requires.js\n// module id = 5\n// module chunks = 0","\nangular.module(\"newsApp\").controller('mainCtrl', function($scope, authService,dataService){\n\t\n\t$scope.template =\n\t    { news: 'templates/news.html',\n\t      auth:'templates/auth.html',\n\t\t  partials:{\n\t\t  \theader:'templates/partials/header.html',\n\t\t\tfooter:'templates/partials/footer.html'\n\t\t  },\t\t  \n\t\t  panel:'templates/panel.html',\n\t\t  panelPartials:{\n\t\t  \tmanageNews:'templates/control-panel/manageNews.html',\n\t\t  \tmanageUsers: 'templates/control-panel/manageUsers.html',\n\t\t  \tmanageSubscriptions:'templates/control-panel/manageSubscriptions.html'\n\t\t  }\n\t};\n\n\t$scope.currentTemplate= $scope.template.news; \n\n\t$scope.changeCurrentTemplate = function(page){\n\t\t$scope.currentTemplate= $scope.template[page];\n\t\t\n\t}\n\n\t\n\n\t/*Noticias*/\n\n\t$scope.newsSelected=false;\n\n\tdataService.getNews(function(res){\n\t\t\t$scope.newsArray=res.data;\n\t\t});\n\t\n\t$scope.showListNewsToEdit= function(){\n\t\t$scope.editing=false;\n \t\t$scope.preview=false;\n \t\t$scope.listNews=true;\n\t}\n\n\t$scope.showNewsToEdit= function(){\n\t\t$scope.editing=true;\n \t\t$scope.listNews=false;\n \t\t$scope.preview= false;\n\t}\n\n\t$scope.showCreateNews= function(){\n\t\t$scope.listNews=false;\n\t\t$scope.editing=true;\n\t \t$scope.create=true;\n\t \t$scope.selectedNews={};\t\n\t}\n\n\t \t$scope.previewNews = function(){\n \t\t$scope.preview=true;\n \t}\n\n \t$scope.addNews= function(news){\n \t\tif ($scope.newsArray.indexOf(news._id)==-1) {\n \t\t\t$scope.newsArray.unshift(news);\n \t\t}\n \t\telse{\n\n \t\t}\n \t\t$scope.showCreateNews();\n \t\t\n \t}\n\n \t$scope.deleteNews =function (news, $index){\n \t\t$scope.newsArray.splice($index, 1)\n \t\tdataService.deleteNews(news);\n\n \t}\n\n \t$scope.saveEditedNews = function(){\n \t\tfor(var prop in $scope.selectedNews) {\n \t\t\t$scope.originalNews[prop]=$scope.selectedNews[prop];\n \t\t\t$scope.showListNewsToEdit();\n \t\t}\n \t}\n\n \t$scope.viewNews= function(news,$index){\n \t\t$scope.selected = true;\n \t\t$scope.news= $scope.newsArray[$index];\n \t}\n\n \t$scope.editSelectedNews= function(news, $index){\n \t\t$scope.showNewsToEdit();\n \t\t$scope.originalNews = $scope.newsArray[$index];\n \t\t$scope.selectedNews =  Object.assign({}, $scope.originalNews);\n \t\t\n\n \t}\n\n \t$scope.goBackFrom= function(from){\n\t\tif (from == 'preview') {\n\t\t\t$scope.preview=false;\n\t\t}\n\t\tif (from == 'editing') {\n\t\t\t$scope.showListNewsToEdit();\n\t\t}\n\t\tif (from== 'view') {\n\t\t\t$scope.selected=false;\n\t\t}\n\n\t}\n\n\t$scope.changePanel= function(panel,option){\n\t\t$scope.activePanel = $scope.template.panelPartials[panel];\n\t\tif(option == 'create' ){\n\t\t\t$scope.showCreateNews();\n\t\t}\n\t\tif (option == 'edit') {\n\t\t\t$scope.showListNewsToEdit();\n\t\t}\n\t\tif (option== 'user') {\n\t\t\t$scope.manageUsers=true;\n\t\t}\n\t\t\n\t}\n\n\t/*Usuarios*/\n\n\tauthService.getUsers(function(res){\n\t\t\t$scope.users=res.data;\n\t\t\t$scope.userLogued = $scope.users[1];\n\t});\t\n\n\t$scope.logoutUser = function (){\n\t\t$scope.userLogued=null;\n\t}\n\n\t$scope.createUser= function(){}\n\n\t$scope.deleteUser= function(){}\n\n\t$scope.changeUserType= function(user, option){\n\t\tif (option == \"promote\") {\n\t\t\tuser.type=\"author\";\n\t\t}\n\t\tif (option == \"demote\") {\n\t\t\tuser.type=\"user\";\n\t\t}\n\n\t}\n\n\t/*Subscripciones*/\n\n\t\n\n\n\n\t\n\t\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./scripts/controllers/mainCtrl.js\n// module id = 6\n// module chunks = 0","angular.module(\"newsApp\").directive('ngUserMenu', function() {\n  return {\n    restrict: 'A',\n    templateUrl: 'templates/control-panel/user.html'\n  }\n});\n\nangular.module(\"newsApp\").directive('ngAuthorMenu', function() {\n  return {\n    restrict: 'A',\n    templateUrl: 'templates/control-panel/author.html'\n  }\n});\n\nangular.module(\"newsApp\").directive('ngAdminMenu', function() {\n  return {\n    restrict: 'A',\n    templateUrl: 'templates/control-panel/admin.html'\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./scripts/directives/ngMenus.js\n// module id = 7\n// module chunks = 0","angular.module(\"newsApp\").service('authService',  function($http){\n\t\n\tthis.getUsers = function(callback){\n\t\t$http.get('mock/users.json')\n\t\t.then(callback);\n\t};\n\t\n\tthis.deleteUser = function(news){\n\n\t}\n\n\tthis.saveUser = function(){\n\n\t}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./scripts/services/authService.js\n// module id = 8\n// module chunks = 0","angular.module(\"newsApp\").service('dataService',  function($http){\n\t\n\tthis.getNews = function(callback){\n\t\t$http.get('mock/news.json')\n\t\t.then(callback);\n\t};\n\t\n\tthis.deleteNews = function(news){\n\n\t}\n\n\tthis.saveNews = function(){\n\n\t}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./scripts/services/dataService.js\n// module id = 9\n// module chunks = 0","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./css/font-awesome.min.css\n// module id = 24\n// module chunks = 0","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./css/main.css\n// module id = 25\n// module chunks = 0","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/bootstrap/dist/css/bootstrap.css\n// module id = 26\n// module chunks = 0","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/textangular/dist/textAngular.css\n// module id = 27\n// module chunks = 0","/**\n * @license AngularJS v1.3.10\n * (c) 2010-2014 Google, Inc. http://angularjs.org\n * License: MIT\n */\n!function(a,b,c){\"use strict\";/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n/*\n * HTML Parser By Misko Hevery (misko@hevery.com)\n * based on:  HTML Parser By John Resig (ejohn.org)\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n *\n * // Use like so:\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n */\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string, however, since our parser is more strict than a typical browser\n *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a\n *   browser, won't make it through the sanitizer. The input may also contain SVG markup.\n *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and\n *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\nfunction d(){this.$get=[\"$$sanitizeUri\",function(a){return function(b){\"undefined\"!=typeof arguments[1]&&(arguments[1].version=\"taSanitize\");var c=[];return g(b,l(c,function(b,c){return!/^unsafe/.test(a(b,c))})),c.join(\"\")}}]}function e(a){var c=[],d=l(c,b.noop);return d.chars(a),c.join(\"\")}function f(a){var b,c={},d=a.split(\",\");for(b=0;b<d.length;b++)c[d[b]]=!0;return c}/**\n * @example\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * @param {string} html string\n * @param {object} handler\n */\nfunction g(a,c){function d(a,d,f,g){if(d=b.lowercase(d),D[d])for(;k.last()&&E[k.last()];)e(\"\",k.last());C[d]&&k.last()==d&&e(\"\",d),g=z[d]||!!g,g||k.push(d);var i={};f.replace(p,function(a,b,c,d,e){var f=c||d||e||\"\";i[b]=h(f)}),c.start&&c.start(d,i,g)}function e(a,d){var e,f=0;if(d=b.lowercase(d))\n// Find the closest opened tag of the same type\nfor(f=k.length-1;f>=0&&k[f]!=d;f--);if(f>=0){\n// Close all the open elements, up the stack\nfor(e=k.length-1;e>=f;e--)c.end&&c.end(k[e]);\n// Remove the open elements from the stack\nk.length=f}}\"string\"!=typeof a&&(a=null===a||\"undefined\"==typeof a?\"\":\"\"+a);var f,g,i,j,k=[],l=a;for(k.last=function(){return k[k.length-1]};a;){\n// Make sure we're not in a script or style element\nif(j=\"\",g=!0,k.last()&&G[k.last()])a=a.replace(new RegExp(\"([^]*)<\\\\s*\\\\/\\\\s*\"+k.last()+\"[^>]*>\",\"i\"),function(a,b){return b=b.replace(s,\"$1\").replace(v,\"$1\"),c.chars&&c.chars(h(b)),\"\"}),e(\"\",k.last());else{\n// White space\nif(y.test(a)){if(i=a.match(y)){i[0];c.whitespace&&c.whitespace(i[0]),a=a.replace(i[0],\"\"),g=!1}}else t.test(a)?(i=a.match(t),i&&(c.comment&&c.comment(i[1]),a=a.replace(i[0],\"\"),g=!1)):u.test(a)?(i=a.match(u),i&&(a=a.replace(i[0],\"\"),g=!1)):r.test(a)?(i=a.match(o),i&&(a=a.substring(i[0].length),i[0].replace(o,e),g=!1)):q.test(a)&&(i=a.match(n),i?(\n// We only have a valid start-tag if there is a '>'.\ni[4]&&(a=a.substring(i[0].length),i[0].replace(n,d)),g=!1):(\n// no ending tag found --- this piece should be encoded as an entity.\nj+=\"<\",a=a.substring(1)));g&&(f=a.indexOf(\"<\"),j+=f<0?a:a.substring(0,f),a=f<0?\"\":a.substring(f),c.chars&&c.chars(h(j)))}if(a==l)throw m(\"badparse\",\"The sanitizer was unable to parse the following block of html: {0}\",a);l=a}\n// Clean up any remaining tags\ne()}/**\n * decodes all entities into regular string\n * @param value\n * @returns {string} A string with decoded entities.\n */\nfunction h(a){if(!a)return\"\";\n// Note: IE8 does not preserve spaces at the start/end of innerHTML\n// so we must capture them and reattach them afterward\nvar b=N.exec(a),c=b[1],d=b[3],e=b[2];\n// innerText depends on styling as it doesn't display hidden elements.\n// Therefore, it's better to use textContent not to cause unnecessary\n// reflows. However, IE<9 don't support textContent so the innerText\n// fallback is necessary.\nreturn e&&(M.innerHTML=e.replace(/</g,\"&lt;\"),e=\"textContent\"in M?M.textContent:M.innerText),c+e+d}/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n * @returns {string} escaped text\n */\nfunction i(a){return a.replace(/&/g,\"&amp;\").replace(w,function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1);return\"&#\"+(1024*(b-55296)+(c-56320)+65536)+\";\"}).replace(x,function(a){\n// unsafe chars are: \\u0000-\\u001f \\u007f-\\u009f \\u00ad \\u0600-\\u0604 \\u070f \\u17b4 \\u17b5 \\u200c-\\u200f \\u2028-\\u202f \\u2060-\\u206f \\ufeff \\ufff0-\\uffff from jslint.com/lint.html\n// decimal values are: 0-31, 127-159, 173, 1536-1540, 1807, 6068, 6069, 8204-8207, 8232-8239, 8288-8303, 65279, 65520-65535\nvar b=a.charCodeAt(0);\n// if unsafe character encode\n// if unsafe character encode\nreturn b<=159||173==b||b>=1536&&b<=1540||1807==b||6068==b||6069==b||b>=8204&&b<=8207||b>=8232&&b<=8239||b>=8288&&b<=8303||65279==b||b>=65520&&b<=65535?\"&#\"+b+\";\":a}).replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\")}\n// Custom logic for accepting certain style options only - textAngular\n// Currently allows only the color, background-color, text-align, float, width and height attributes\n// all other attributes should be easily done through classes.\nfunction j(a){var c=\"\",d=a.split(\";\");return b.forEach(d,function(a){var d=a.split(\":\");if(2==d.length){var e=O(b.lowercase(d[0])),a=O(b.lowercase(d[1]));((\"color\"===e||\"background-color\"===e)&&(a.match(/^rgb\\([0-9%,\\. ]*\\)$/i)||a.match(/^rgba\\([0-9%,\\. ]*\\)$/i)||a.match(/^hsl\\([0-9%,\\. ]*\\)$/i)||a.match(/^hsla\\([0-9%,\\. ]*\\)$/i)||a.match(/^#[0-9a-f]{3,6}$/i)||a.match(/^[a-z]*$/i))||\"text-align\"===e&&(\"left\"===a||\"right\"===a||\"center\"===a||\"justify\"===a)||\"text-decoration\"===e&&(\"underline\"===a||\"line-through\"===a)||\"font-weight\"===e&&\"bold\"===a||\"font-style\"===e&&\"italic\"===a||\"float\"===e&&(\"left\"===a||\"right\"===a||\"none\"===a)||\"vertical-align\"===e&&(\"baseline\"===a||\"sub\"===a||\"super\"===a||\"test-top\"===a||\"text-bottom\"===a||\"middle\"===a||\"top\"===a||\"bottom\"===a||a.match(/[0-9]*(px|em)/)||a.match(/[0-9]+?%/))||\"font-size\"===e&&(\"xx-small\"===a||\"x-small\"===a||\"small\"===a||\"medium\"===a||\"large\"===a||\"x-large\"===a||\"xx-large\"===a||\"larger\"===a||\"smaller\"===a||a.match(/[0-9]*\\.?[0-9]*(px|em|rem|mm|q|cm|in|pt|pc|%)/))||(\"width\"===e||\"height\"===e)&&a.match(/[0-9\\.]*(px|em|rem|%)/)||// Reference #520\n\"direction\"===e&&a.match(/^ltr|rtl|initial|inherit$/))&&(c+=e+\": \"+a+\";\")}}),c}\n// this function is used to manually allow specific attributes on specific tags with certain prerequisites\nfunction k(a,b,c,d){\n// catch the div placeholder for the iframe replacement\nreturn!(\"img\"!==a||!b[\"ta-insert-video\"]||\"ta-insert-video\"!==c&&\"allowfullscreen\"!==c&&\"frameborder\"!==c&&(\"contenteditable\"!==c||\"false\"!==d))}/**\n * create an HTML/XML writer which writes to buffer\n * @param {Array} buf use buf.jain('') to get out sanitized html string\n * @returns {object} in the form of {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * }\n */\nfunction l(a,c){var d=!1,e=b.bind(a,a.push);return{start:function(a,f,g){a=b.lowercase(a),!d&&G[a]&&(d=a),d||H[a]!==!0||(e(\"<\"),e(a),b.forEach(f,function(d,g){var h=b.lowercase(g),l=\"img\"===a&&\"src\"===h||\"background\"===h;(\"style\"===h&&\"\"!==(d=j(d))||k(a,f,h,d)||L[h]===!0&&(I[h]!==!0||c(d,l)))&&(e(\" \"),e(g),e('=\"'),e(i(d)),e('\"'))}),e(g?\"/>\":\">\"))},comment:function(a){e(a)},whitespace:function(a){e(i(a))},end:function(a){a=b.lowercase(a),d||H[a]!==!0||(e(\"</\"),e(a),e(\">\")),a==d&&(d=!1)},chars:function(a){d||e(i(a))}}}var m=b.$$minErr(\"$sanitize\"),n=/^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,o=/^<\\/\\s*([\\w:-]+)[^>]*>/,p=/([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,q=/^</,r=/^<\\//,s=/<!--(.*?)-->/g,t=/(^<!--.*?-->)/,u=/<!DOCTYPE([^>]*?)>/i,v=/<!\\[CDATA\\[(.*?)]]>/g,w=/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n// Match everything outside of normal chars and \" (quote character)\nx=/([^\\#-~| |!])/g,y=/^(\\s+)/,z=f(\"area,br,col,hr,img,wbr,input\"),A=f(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),B=f(\"rp,rt\"),C=b.extend({},B,A),D=b.extend({},A,f(\"address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul\")),E=b.extend({},B,f(\"a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var\")),F=f(\"animate,animateColor,animateMotion,animateTransform,circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set,stop,svg,switch,text,title,tspan,use\"),G=f(\"script,style\"),H=b.extend({},z,D,E,C,F),I=f(\"background,cite,href,longdesc,src,usemap,xlink:href\"),J=f(\"abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,id,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,target,title,type,valign,value,vspace,width\"),K=f(\"accent-height,accumulate,additive,alphabetic,arabic-form,ascent,attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan\"),L=b.extend({},I,K,J),M=document.createElement(\"pre\"),N=/^(\\s*)([\\s\\S]*?)(\\s*)$/,O=function(){\n// native trim is way faster: http://jsperf.com/angular-trim-test\n// but IE doesn't have it... :-(\n// TODO: we should move this into IE/ES5 polyfill\n// native trim is way faster: http://jsperf.com/angular-trim-test\n// but IE doesn't have it... :-(\n// TODO: we should move this into IE/ES5 polyfill\nreturn String.prototype.trim?function(a){return b.isString(a)?a.trim():a}:function(a){return b.isString(a)?a.replace(/^\\s\\s*/,\"\").replace(/\\s\\s*$/,\"\"):a}}();\n// define ngSanitize module and register $sanitize service\nb.module(\"ngSanitize\",[]).provider(\"$sanitize\",d),/* global sanitizeText: false */\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.\n * @returns {string} Html-linkified text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n       <script>\n         angular.module('linkyExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', function($scope) {\n             $scope.snippet =\n               'Pretty text with some links:\\n'+\n               'http://angularjs.org/,\\n'+\n               'mailto:us@somewhere.org,\\n'+\n               'another@somewhere.org,\\n'+\n               'and one more: ftp://127.0.0.1/.';\n             $scope.snippetWithTarget = 'http://angularjs.org/';\n           }]);\n       </script>\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Filter</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithTarget | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n     </file>\n   </example>\n */\nb.module(\"ngSanitize\").filter(\"linky\",[\"$sanitize\",function(a){var c=/((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"”’]/,d=/^mailto:/;return function(f,g){function h(a){a&&n.push(e(a))}function i(a,c){n.push(\"<a \"),b.isDefined(g)&&n.push('target=\"',g,'\" '),n.push('href=\"',a.replace(/\"/g,\"&quot;\"),'\">'),h(c),n.push(\"</a>\")}if(!f)return f;for(var j,k,l,m=f,n=[];j=m.match(c);)\n// We can not end in these as they are sometimes found at the end of the sentence\nk=j[0],\n// if we did not match ftp/http/www/mailto then assume mailto\nj[2]||j[4]||(k=(j[3]?\"http://\":\"mailto:\")+k),l=j.index,h(m.substr(0,l)),i(k,j[0].replace(d,\"\")),m=m.substring(l+j[0].length);return h(m),a(n.join(\"\"))}}])}(window,window.angular);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/textangular/dist/textAngular-sanitize.min.js\n// module id = 28\n// module chunks = 0","!function(a,b){\"function\"==typeof define&&define.amd?\n// AMD. Register as an anonymous module unless amdModuleId is set\ndefine(\"textAngular\",[\"rangy\",\"rangy/lib/rangy-selectionsaverestore\"],function(c,d){return a[\"textAngular.name\"]=b(c,d)}):\"object\"==typeof exports?\n// Node. Does not work with strict CommonJS, but\n// only CommonJS-like environments that support module.exports,\n// like Node.\nmodule.exports=b(require(\"rangy\"),require(\"rangy/lib/rangy-selectionsaverestore\")):a.textAngular=b(rangy)}(this,function(a){\n// tests against the current jqLite/jquery implementation if this can be an element\nfunction b(a){try{return 0!==angular.element(a).length}catch(a){return!1}}/*\n    A tool definition is an object with the following key/value parameters:\n        action: [function(deferred, restoreSelection)]\n                a function that is executed on clicking on the button - this will allways be executed using ng-click and will\n                overwrite any ng-click value in the display attribute.\n                The function is passed a deferred object ($q.defer()), if this is wanted to be used `return false;` from the action and\n                manually call `deferred.resolve();` elsewhere to notify the editor that the action has finished.\n                restoreSelection is only defined if the rangy library is included and it can be called as `restoreSelection()` to restore the users\n                selection in the WYSIWYG editor.\n        display: [string]?\n                Optional, an HTML element to be displayed as the button. The `scope` of the button is the tool definition object with some additional functions\n                If set this will cause buttontext and iconclass to be ignored\n        class: [string]?\n                Optional, if set will override the taOptions.classes.toolbarButton class.\n        buttontext: [string]?\n                if this is defined it will replace the contents of the element contained in the `display` element\n        iconclass: [string]?\n                if this is defined an icon (<i>) will be appended to the `display` element with this string as it's class\n        tooltiptext: [string]?\n                Optional, a plain text description of the action, used for the title attribute of the action button in the toolbar by default.\n        activestate: [function(commonElement)]?\n                this function is called on every caret movement, if it returns true then the class taOptions.classes.toolbarButtonActive\n                will be applied to the `display` element, else the class will be removed\n        disabled: [function()]?\n                if this function returns true then the tool will have the class taOptions.classes.disabled applied to it, else it will be removed\n    Other functions available on the scope are:\n        name: [string]\n                the name of the tool, this is the first parameter passed into taRegisterTool\n        isDisabled: [function()]\n                returns true if the tool is disabled, false if it isn't\n        displayActiveToolClass: [function(boolean)]\n                returns true if the tool is 'active' in the currently focussed toolbar\n        onElementSelect: [Object]\n                This object contains the following key/value pairs and is used to trigger the ta-element-select event\n                element: [String]\n                    an element name, will only trigger the onElementSelect action if the tagName of the element matches this string\n                filter: [function(element)]?\n                    an optional filter that returns a boolean, if true it will trigger the onElementSelect.\n                action: [function(event, element, editorScope)]\n                    the action that should be executed if the onElementSelect function runs\n*/\n// name and toolDefinition to add into the tools available to be added on the toolbar\nfunction c(a,c){if(!a||\"\"===a||e.hasOwnProperty(a))throw\"textAngular Error: A unique name is required for a Tool Definition\";if(c.display&&(\"\"===c.display||!b(c.display))||!c.display&&!c.buttontext&&!c.iconclass)throw'textAngular Error: Tool Definition for \"'+a+'\" does not have a valid display/iconclass/buttontext value';e[a]=c}\n// usage is:\n// var t0 = performance.now();\n// doSomething();\n// var t1 = performance.now();\n// console.log('Took', (t1 - t0).toFixed(4), 'milliseconds to do something!');\n//\n// turn html into pure text that shows visiblity\nfunction d(a){var b=document.createElement(\"DIV\");b.innerHTML=a;var c=b.textContent||b.innerText||\"\";// zero width space\nreturn c.replace(\"​\",\"\"),c=c.trim()}\n// setup the global contstant functions for setting up the toolbar\n// all tool definitions\nvar e={};angular.module(\"textAngularSetup\",[]).constant(\"taRegisterTool\",c).value(\"taTools\",e).value(\"taOptions\",{\n//////////////////////////////////////////////////////////////////////////////////////\n// forceTextAngularSanitize\n// set false to allow the textAngular-sanitize provider to be replaced\n// with angular-sanitize or a custom provider.\nforceTextAngularSanitize:!0,\n///////////////////////////////////////////////////////////////////////////////////////\n// keyMappings\n// allow customizable keyMappings for specialized key boards or languages\n//\n// keyMappings provides key mappings that are attached to a given commandKeyCode.\n// To modify a specific keyboard binding, simply provide function which returns true\n// for the event you wish to map to.\n// Or to disable a specific keyboard binding, provide a function which returns false.\n// Note: 'RedoKey' and 'UndoKey' are internally bound to the redo and undo functionality.\n// At present, the following commandKeyCodes are in use:\n// 98, 'TabKey', 'ShiftTabKey', 105, 117, 'UndoKey', 'RedoKey'\n//\n// To map to an new commandKeyCode, add a new key mapping such as:\n// {commandKeyCode: 'CustomKey', testForKey: function (event) {\n//  if (event.keyCode=57 && event.ctrlKey && !event.shiftKey && !event.altKey) return true;\n// } }\n// to the keyMappings. This example maps ctrl+9 to 'CustomKey'\n// Then where taRegisterTool(...) is called, add a commandKeyCode: 'CustomKey' and your\n// tool will be bound to ctrl+9.\n//\n// To disble one of the already bound commandKeyCodes such as 'RedoKey' or 'UndoKey' add:\n// {commandKeyCode: 'RedoKey', testForKey: function (event) { return false; } },\n// {commandKeyCode: 'UndoKey', testForKey: function (event) { return false; } },\n// to disable them.\n//\nkeyMappings:[],toolbar:[[\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"p\",\"pre\",\"quote\"],[\"bold\",\"italics\",\"underline\",\"strikeThrough\",\"ul\",\"ol\",\"redo\",\"undo\",\"clear\"],[\"justifyLeft\",\"justifyCenter\",\"justifyRight\",\"justifyFull\",\"indent\",\"outdent\"],[\"html\",\"insertImage\",\"insertLink\",\"insertVideo\",\"wordcount\",\"charcount\"]],classes:{focussed:\"focussed\",toolbar:\"btn-toolbar\",toolbarGroup:\"btn-group\",toolbarButton:\"btn btn-default\",toolbarButtonActive:\"active\",disabled:\"disabled\",textEditor:\"form-control\",htmlEditor:\"form-control\"},defaultTagAttributes:{a:{target:\"\"}},setup:{\n// wysiwyg mode\ntextEditorSetup:function(a){},\n// raw html\nhtmlEditorSetup:function(a){}},defaultFileDropHandler:/* istanbul ignore next: untestable image processing */\nfunction(a,b){var c=new FileReader;return\"image\"===a.type.substring(0,5)&&(c.onload=function(){\"\"!==c.result&&b(\"insertImage\",c.result,!0)},c.readAsDataURL(a),!0)}}).value(\"taSelectableElements\",[\"a\",\"img\"]).value(\"taCustomRenderers\",[{\n// Parse back out: '<div class=\"ta-insert-video\" ta-insert-video src=\"' + urlLink + '\" allowfullscreen=\"true\" width=\"300\" frameborder=\"0\" height=\"250\"></div>'\n// To correct video element. For now only support youtube\nselector:\"img\",customAttribute:\"ta-insert-video\",renderLogic:function(a){var b=angular.element(\"<iframe></iframe>\"),c=a.prop(\"attributes\");\n// loop through element attributes and apply them on iframe\nangular.forEach(c,function(a){b.attr(a.name,a.value)}),b.attr(\"src\",b.attr(\"ta-insert-video\")),a.replaceWith(b)}}]).value(\"taTranslations\",{\n// moved to sub-elements\n//toggleHTML: \"Toggle HTML\",\n//insertImage: \"Please enter a image URL to insert\",\n//insertLink: \"Please enter a URL to insert\",\n//insertVideo: \"Please enter a youtube URL to embed\",\nhtml:{tooltip:\"Toggle html / Rich Text\"},\n// tooltip for heading - might be worth splitting\nheading:{tooltip:\"Heading \"},p:{tooltip:\"Paragraph\"},pre:{tooltip:\"Preformatted text\"},ul:{tooltip:\"Unordered List\"},ol:{tooltip:\"Ordered List\"},quote:{tooltip:\"Quote/unquote selection or paragraph\"},undo:{tooltip:\"Undo\"},redo:{tooltip:\"Redo\"},bold:{tooltip:\"Bold\"},italic:{tooltip:\"Italic\"},underline:{tooltip:\"Underline\"},strikeThrough:{tooltip:\"Strikethrough\"},justifyLeft:{tooltip:\"Align text left\"},justifyRight:{tooltip:\"Align text right\"},justifyFull:{tooltip:\"Justify text\"},justifyCenter:{tooltip:\"Center\"},indent:{tooltip:\"Increase indent\"},outdent:{tooltip:\"Decrease indent\"},clear:{tooltip:\"Clear formatting\"},insertImage:{dialogPrompt:\"Please enter an image URL to insert\",tooltip:\"Insert image\",hotkey:\"the - possibly language dependent hotkey ... for some future implementation\"},insertVideo:{tooltip:\"Insert video\",dialogPrompt:\"Please enter a youtube URL to embed\"},insertLink:{tooltip:\"Insert / edit link\",dialogPrompt:\"Please enter a URL to insert\"},editLink:{reLinkButton:{tooltip:\"Relink\"},unLinkButton:{tooltip:\"Unlink\"},targetToggle:{buttontext:\"Open in New Window\"}},wordcount:{tooltip:\"Display words Count\"},charcount:{tooltip:\"Display characters Count\"}}).factory(\"taToolFunctions\",[\"$window\",\"taTranslations\",function(a,b){return{imgOnSelectAction:function(a,b,c){\n// setup the editor toolbar\n// Credit to the work at http://hackerwins.github.io/summernote/ for this editbar logic/display\nvar d=function(){c.updateTaBindtaTextElement(),c.hidePopover()};a.preventDefault(),c.displayElements.popover.css(\"width\",\"375px\");var e=c.displayElements.popoverContainer;e.empty();var f=angular.element('<div class=\"btn-group\" style=\"padding-right: 6px;\">'),g=angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">100% </button>');g.on(\"click\",function(a){a.preventDefault(),b.css({width:\"100%\",height:\"\"}),d()});var h=angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">50% </button>');h.on(\"click\",function(a){a.preventDefault(),b.css({width:\"50%\",height:\"\"}),d()});var i=angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">25% </button>');i.on(\"click\",function(a){a.preventDefault(),b.css({width:\"25%\",height:\"\"}),d()});var j=angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\">Reset</button>');j.on(\"click\",function(a){a.preventDefault(),b.css({width:\"\",height:\"\"}),d()}),f.append(g),f.append(h),f.append(i),f.append(j),e.append(f),f=angular.element('<div class=\"btn-group\" style=\"padding-right: 6px;\">');var k=angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-align-left\"></i></button>');k.on(\"click\",function(a){a.preventDefault(),\n// webkit\nb.css(\"float\",\"left\"),\n// firefox\nb.css(\"cssFloat\",\"left\"),\n// IE < 8\nb.css(\"styleFloat\",\"left\"),d()});var l=angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-align-right\"></i></button>');l.on(\"click\",function(a){a.preventDefault(),\n// webkit\nb.css(\"float\",\"right\"),\n// firefox\nb.css(\"cssFloat\",\"right\"),\n// IE < 8\nb.css(\"styleFloat\",\"right\"),d()});var m=angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-align-justify\"></i></button>');m.on(\"click\",function(a){a.preventDefault(),\n// webkit\nb.css(\"float\",\"\"),\n// firefox\nb.css(\"cssFloat\",\"\"),\n// IE < 8\nb.css(\"styleFloat\",\"\"),d()}),f.append(k),f.append(m),f.append(l),e.append(f),f=angular.element('<div class=\"btn-group\">');var n=angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" unselectable=\"on\" tabindex=\"-1\"><i class=\"fa fa-trash-o\"></i></button>');n.on(\"click\",function(a){a.preventDefault(),b.remove(),d()}),f.append(n),e.append(f),c.showPopover(b),c.showResizeOverlay(b)},aOnSelectAction:function(c,d,e){\n// setup the editor toolbar\n// Credit to the work at http://hackerwins.github.io/summernote/ for this editbar logic\nc.preventDefault(),e.displayElements.popover.css(\"width\",\"436px\");var f=e.displayElements.popoverContainer;f.empty(),f.css(\"line-height\",\"28px\");var g=angular.element('<a href=\"'+d.attr(\"href\")+'\" target=\"_blank\">'+d.attr(\"href\")+\"</a>\");g.css({display:\"inline-block\",\"max-width\":\"200px\",overflow:\"hidden\",\"text-overflow\":\"ellipsis\",\"white-space\":\"nowrap\",\"vertical-align\":\"middle\"}),f.append(g);var h=angular.element('<div class=\"btn-group pull-right\">'),i=angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" tabindex=\"-1\" unselectable=\"on\" title=\"'+b.editLink.reLinkButton.tooltip+'\"><i class=\"fa fa-edit icon-edit\"></i></button>');i.on(\"click\",function(c){c.preventDefault();var f=a.prompt(b.insertLink.dialogPrompt,d.attr(\"href\"));f&&\"\"!==f&&\"http://\"!==f&&(d.attr(\"href\",f),e.updateTaBindtaTextElement()),e.hidePopover()}),h.append(i);var j=angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" tabindex=\"-1\" unselectable=\"on\" title=\"'+b.editLink.unLinkButton.tooltip+'\"><i class=\"fa fa-unlink icon-unlink\"></i></button>');\n// directly before this click event is fired a digest is fired off whereby the reference to $element is orphaned off\nj.on(\"click\",function(a){a.preventDefault(),d.replaceWith(d.contents()),e.updateTaBindtaTextElement(),e.hidePopover()}),h.append(j);var k=angular.element('<button type=\"button\" class=\"btn btn-default btn-sm btn-small\" tabindex=\"-1\" unselectable=\"on\">'+b.editLink.targetToggle.buttontext+\"</button>\");\"_blank\"===d.attr(\"target\")&&k.addClass(\"active\"),k.on(\"click\",function(a){a.preventDefault(),d.attr(\"target\",\"_blank\"===d.attr(\"target\")?\"\":\"_blank\"),k.toggleClass(\"active\"),e.updateTaBindtaTextElement()}),h.append(k),f.append(h),e.showPopover(d)},extractYoutubeVideoId:function(a){var b=/(?:youtube(?:-nocookie)?\\.com\\/(?:[^\\/\\n\\s]+\\/\\S+\\/|(?:v|e(?:mbed)?)\\/|\\S*?[?&]v=)|youtu\\.be\\/)([a-zA-Z0-9_-]{11})/i,c=a.match(b);return c&&c[1]||null}}}]).run([\"taRegisterTool\",\"$window\",\"taTranslations\",\"taSelection\",\"taToolFunctions\",\"$sanitize\",\"taOptions\",\"$log\",function(a,b,c,d,e,f,g,h){\n// test for the version of $sanitize that is in use\n// You can disable this check by setting taOptions.textAngularSanitize == false\nvar i={};/* istanbul ignore next, throws error */\nif(f(\"\",i),g.forceTextAngularSanitize===!0&&\"taSanitize\"!==i.version)throw angular.$$minErr(\"textAngular\")(\"textAngularSetup\",\"The textAngular-sanitize provider has been replaced by another -- have you included angular-sanitize by mistake?\");a(\"html\",{iconclass:\"fa fa-code\",tooltiptext:c.html.tooltip,action:function(){this.$editor().switchView()},activeState:function(){return this.$editor().showHtml}});\n// add the Header tools\n// convenience functions so that the loop works correctly\nvar j=function(a){return function(){return this.$editor().queryFormatBlockState(a)}},k=function(){return this.$editor().wrapSelection(\"formatBlock\",\"<\"+this.name.toUpperCase()+\">\")};angular.forEach([\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\"],function(b){a(b.toLowerCase(),{buttontext:b.toUpperCase(),tooltiptext:c.heading.tooltip+b.charAt(1),action:k,activeState:j(b.toLowerCase())})}),a(\"p\",{buttontext:\"P\",tooltiptext:c.p.tooltip,action:function(){return this.$editor().wrapSelection(\"formatBlock\",\"<P>\")},activeState:function(){return this.$editor().queryFormatBlockState(\"p\")}}),\n// key: pre -> taTranslations[key].tooltip, taTranslations[key].buttontext\na(\"pre\",{buttontext:\"pre\",tooltiptext:c.pre.tooltip,action:function(){return this.$editor().wrapSelection(\"formatBlock\",\"<PRE>\")},activeState:function(){return this.$editor().queryFormatBlockState(\"pre\")}}),a(\"ul\",{iconclass:\"fa fa-list-ul\",tooltiptext:c.ul.tooltip,action:function(){return this.$editor().wrapSelection(\"insertUnorderedList\",null)},activeState:function(){return this.$editor().queryCommandState(\"insertUnorderedList\")}}),a(\"ol\",{iconclass:\"fa fa-list-ol\",tooltiptext:c.ol.tooltip,action:function(){return this.$editor().wrapSelection(\"insertOrderedList\",null)},activeState:function(){return this.$editor().queryCommandState(\"insertOrderedList\")}}),a(\"quote\",{iconclass:\"fa fa-quote-right\",tooltiptext:c.quote.tooltip,action:function(){return this.$editor().wrapSelection(\"formatBlock\",\"<BLOCKQUOTE>\")},activeState:function(){return this.$editor().queryFormatBlockState(\"blockquote\")}}),a(\"undo\",{iconclass:\"fa fa-undo\",tooltiptext:c.undo.tooltip,action:function(){return this.$editor().wrapSelection(\"undo\",null)}}),a(\"redo\",{iconclass:\"fa fa-repeat\",tooltiptext:c.redo.tooltip,action:function(){return this.$editor().wrapSelection(\"redo\",null)}}),a(\"bold\",{iconclass:\"fa fa-bold\",tooltiptext:c.bold.tooltip,action:function(){return this.$editor().wrapSelection(\"bold\",null)},activeState:function(){return this.$editor().queryCommandState(\"bold\")},commandKeyCode:98}),a(\"justifyLeft\",{iconclass:\"fa fa-align-left\",tooltiptext:c.justifyLeft.tooltip,action:function(){return this.$editor().wrapSelection(\"justifyLeft\",null)},activeState:function(a){/* istanbul ignore next: */\nif(a&&\"#document\"===a.nodeName)return!1;var b=!1;if(a)\n// commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n// so we do try catch here...\ntry{b=\"left\"===a.css(\"text-align\")||\"left\"===a.attr(\"align\")||\"right\"!==a.css(\"text-align\")&&\"center\"!==a.css(\"text-align\")&&\"justify\"!==a.css(\"text-align\")&&!this.$editor().queryCommandState(\"justifyRight\")&&!this.$editor().queryCommandState(\"justifyCenter\")&&!this.$editor().queryCommandState(\"justifyFull\")}catch(a){/* istanbul ignore next: error handler */\n//console.log(e);\nb=!1}return b=b||this.$editor().queryCommandState(\"justifyLeft\")}}),a(\"justifyRight\",{iconclass:\"fa fa-align-right\",tooltiptext:c.justifyRight.tooltip,action:function(){return this.$editor().wrapSelection(\"justifyRight\",null)},activeState:function(a){/* istanbul ignore next: */\nif(a&&\"#document\"===a.nodeName)return!1;var b=!1;if(a)\n// commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n// so we do try catch here...\ntry{b=\"right\"===a.css(\"text-align\")}catch(a){/* istanbul ignore next: error handler */\n//console.log(e);\nb=!1}return b=b||this.$editor().queryCommandState(\"justifyRight\")}}),a(\"justifyFull\",{iconclass:\"fa fa-align-justify\",tooltiptext:c.justifyFull.tooltip,action:function(){return this.$editor().wrapSelection(\"justifyFull\",null)},activeState:function(a){var b=!1;if(a)\n// commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n// so we do try catch here...\ntry{b=\"justify\"===a.css(\"text-align\")}catch(a){/* istanbul ignore next: error handler */\n//console.log(e);\nb=!1}return b=b||this.$editor().queryCommandState(\"justifyFull\")}}),a(\"justifyCenter\",{iconclass:\"fa fa-align-center\",tooltiptext:c.justifyCenter.tooltip,action:function(){return this.$editor().wrapSelection(\"justifyCenter\",null)},activeState:function(a){/* istanbul ignore next: */\nif(a&&\"#document\"===a.nodeName)return!1;var b=!1;if(a)\n// commonELement.css('text-align') can throw an error 'Cannot read property 'defaultView' of null' in rare conditions\n// so we do try catch here...\ntry{b=\"center\"===a.css(\"text-align\")}catch(a){/* istanbul ignore next: error handler */\n//console.log(e);\nb=!1}return b=b||this.$editor().queryCommandState(\"justifyCenter\")}}),a(\"indent\",{iconclass:\"fa fa-indent\",tooltiptext:c.indent.tooltip,action:function(){return this.$editor().wrapSelection(\"indent\",null)},activeState:function(){return this.$editor().queryFormatBlockState(\"blockquote\")},commandKeyCode:\"TabKey\"}),a(\"outdent\",{iconclass:\"fa fa-outdent\",tooltiptext:c.outdent.tooltip,action:function(){return this.$editor().wrapSelection(\"outdent\",null)},activeState:function(){return!1},commandKeyCode:\"ShiftTabKey\"}),a(\"italics\",{iconclass:\"fa fa-italic\",tooltiptext:c.italic.tooltip,action:function(){return this.$editor().wrapSelection(\"italic\",null)},activeState:function(){return this.$editor().queryCommandState(\"italic\")},commandKeyCode:105}),a(\"underline\",{iconclass:\"fa fa-underline\",tooltiptext:c.underline.tooltip,action:function(){return this.$editor().wrapSelection(\"underline\",null)},activeState:function(){return this.$editor().queryCommandState(\"underline\")},commandKeyCode:117}),a(\"strikeThrough\",{iconclass:\"fa fa-strikethrough\",tooltiptext:c.strikeThrough.tooltip,action:function(){return this.$editor().wrapSelection(\"strikeThrough\",null)},activeState:function(){return document.queryCommandState(\"strikeThrough\")}}),a(\"clear\",{iconclass:\"fa fa-ban\",tooltiptext:c.clear.tooltip,action:function(a,b){var c;this.$editor().wrapSelection(\"removeFormat\",null);var e=angular.element(d.getSelectionElement());c=d.getAllSelectedElements();\n//$log.log('selectedElements:', selectedElements);\n// remove lists\nvar f=function(a,b){a=angular.element(a);var c=b;return b||(c=a),angular.forEach(a.children(),function(a){if(\"ul\"===a.tagName.toLowerCase()||\"ol\"===a.tagName.toLowerCase())c=f(a,c);else{var b=angular.element(\"<p></p>\");b.html(angular.element(a).html()),c.after(b),c=b}}),a.remove(),c};angular.forEach(c,function(a){\"ul\"!==a.nodeName.toLowerCase()&&\"ol\"!==a.nodeName.toLowerCase()||\n//console.log('removeListElements', element);\nf(a)}),angular.forEach(e.find(\"ul\"),f),angular.forEach(e.find(\"ol\"),f);\n// clear out all class attributes. These do not seem to be cleared via removeFormat\nvar g=this.$editor(),h=function(a){a=angular.element(a),/* istanbul ignore next: this is not triggered in tests any longer since we now never select the whole displayELement */\na[0]!==g.displayElements.text[0]&&a.removeAttr(\"class\"),angular.forEach(a.children(),h)};angular.forEach(e,h),\n// check if in list. If not in list then use formatBlock option\ne[0]&&\"li\"!==e[0].tagName.toLowerCase()&&\"ol\"!==e[0].tagName.toLowerCase()&&\"ul\"!==e[0].tagName.toLowerCase()&&\"true\"!==e[0].getAttribute(\"contenteditable\")&&this.$editor().wrapSelection(\"formatBlock\",\"default\"),b()}});/* jshint -W099 */\n/****************************\n     //  we don't use this code - since the previous way CLEAR is expected to work does not clear partially selected <li>\n\n     var removeListElement = function(listE){\n                console.log(listE);\n                var _list = listE.parentNode.childNodes;\n                console.log('_list', _list);\n                var _preLis = [], _postLis = [], _found = false;\n                for (i = 0; i < _list.length; i++) {\n                    if (_list[i] === listE) {\n                        _found = true;\n                    } else if (!_found) _preLis.push(_list[i]);\n                    else _postLis.push(_list[i]);\n                }\n                var _parent = angular.element(listE.parentNode);\n                var newElem = angular.element('<p></p>');\n                newElem.html(angular.element(listE).html());\n                if (_preLis.length === 0 || _postLis.length === 0) {\n                    if (_postLis.length === 0) _parent.after(newElem);\n                    else _parent[0].parentNode.insertBefore(newElem[0], _parent[0]);\n\n                    if (_preLis.length === 0 && _postLis.length === 0) _parent.remove();\n                    else angular.element(listE).remove();\n                } else {\n                    var _firstList = angular.element('<' + _parent[0].tagName + '></' + _parent[0].tagName + '>');\n                    var _secondList = angular.element('<' + _parent[0].tagName + '></' + _parent[0].tagName + '>');\n                    for (i = 0; i < _preLis.length; i++) _firstList.append(angular.element(_preLis[i]));\n                    for (i = 0; i < _postLis.length; i++) _secondList.append(angular.element(_postLis[i]));\n                    _parent.after(_secondList);\n                    _parent.after(newElem);\n                    _parent.after(_firstList);\n                    _parent.remove();\n                }\n                taSelection.setSelectionToElementEnd(newElem[0]);\n            };\n\n     elementsSeen = [];\n     if (selectedElements.length !==0) console.log(selectedElements);\n     angular.forEach(selectedElements, function (element) {\n                if (elementsSeen.indexOf(element) !== -1 || elementsSeen.indexOf(element.parentElement) !== -1) {\n                    return;\n                }\n                elementsSeen.push(element);\n                if (element.nodeName.toLowerCase() === 'li') {\n                    console.log('removeListElement', element);\n                    removeListElement(element);\n                }\n                else if (element.parentElement && element.parentElement.nodeName.toLowerCase() === 'li') {\n                    console.log('removeListElement', element.parentElement);\n                    elementsSeen.push(element.parentElement);\n                    removeListElement(element.parentElement);\n                }\n            });\n     **********************/\n/**********************\n     if(possibleNodes[0].tagName.toLowerCase() === 'li'){\n                var _list = possibleNodes[0].parentNode.childNodes;\n                var _preLis = [], _postLis = [], _found = false;\n                for(i = 0; i < _list.length; i++){\n                    if(_list[i] === possibleNodes[0]){\n                        _found = true;\n                    }else if(!_found) _preLis.push(_list[i]);\n                    else _postLis.push(_list[i]);\n                }\n                var _parent = angular.element(possibleNodes[0].parentNode);\n                var newElem = angular.element('<p></p>');\n                newElem.html(angular.element(possibleNodes[0]).html());\n                if(_preLis.length === 0 || _postLis.length === 0){\n                    if(_postLis.length === 0) _parent.after(newElem);\n                    else _parent[0].parentNode.insertBefore(newElem[0], _parent[0]);\n\n                    if(_preLis.length === 0 && _postLis.length === 0) _parent.remove();\n                    else angular.element(possibleNodes[0]).remove();\n                }else{\n                    var _firstList = angular.element('<'+_parent[0].tagName+'></'+_parent[0].tagName+'>');\n                    var _secondList = angular.element('<'+_parent[0].tagName+'></'+_parent[0].tagName+'>');\n                    for(i = 0; i < _preLis.length; i++) _firstList.append(angular.element(_preLis[i]));\n                    for(i = 0; i < _postLis.length; i++) _secondList.append(angular.element(_postLis[i]));\n                    _parent.after(_secondList);\n                    _parent.after(newElem);\n                    _parent.after(_firstList);\n                    _parent.remove();\n                }\n                taSelection.setSelectionToElementEnd(newElem[0]);\n            }\n     *******************/\n/* istanbul ignore next: if it's javascript don't worry - though probably should show some kind of error message */\nvar l=function(a){return a.toLowerCase().indexOf(\"javascript\")!==-1};a(\"insertImage\",{iconclass:\"fa fa-picture-o\",tooltiptext:c.insertImage.tooltip,action:function(){var a;if(a=b.prompt(c.insertImage.dialogPrompt,\"http://\"),a&&\"\"!==a&&\"http://\"!==a&&!l(a)){d.getSelectionElement().tagName&&\"a\"===d.getSelectionElement().tagName.toLowerCase()&&\n// due to differences in implementation between FireFox and Chrome, we must move the\n// insertion point past the <a> element, otherwise FireFox inserts inside the <a>\n// With this change, both FireFox and Chrome behave the same way!\nd.setSelectionAfterElement(d.getSelectionElement());\n// In the past we used the simple statement:\n//return this.$editor().wrapSelection('insertImage', imageLink, true);\n//\n// However on Firefox only, when the content is empty this is a problem\n// See Issue #1201\n// Investigation reveals that Firefox only inserts a <p> only!!!!\n// So now we use insertHTML here and all is fine.\n// NOTE: this is what 'insertImage' is supposed to do anyway!\nvar e='<img src=\"'+a+'\">';return this.$editor().wrapSelection(\"insertHTML\",e,!0)}},onElementSelect:{element:\"img\",action:e.imgOnSelectAction}}),a(\"insertVideo\",{iconclass:\"fa fa-youtube-play\",tooltiptext:c.insertVideo.tooltip,action:function(){var a;\n// block javascript here\n/* istanbul ignore else: if it's javascript don't worry - though probably should show some kind of error message */\nif(a=b.prompt(c.insertVideo.dialogPrompt,\"https://\"),!l(a)&&a&&\"\"!==a&&\"https://\"!==a&&(videoId=e.extractYoutubeVideoId(a),videoId)){\n// create the embed link\nvar f=\"https://www.youtube.com/embed/\"+videoId,g='<img class=\"ta-insert-video\" src=\"https://img.youtube.com/vi/'+videoId+'/hqdefault.jpg\" ta-insert-video=\"'+f+'\" contenteditable=\"false\" allowfullscreen=\"true\" frameborder=\"0\" />';\n// insert\n/* istanbul ignore next: don't know how to test this... since it needs a dialogPrompt */\n// due to differences in implementation between FireFox and Chrome, we must move the\n// insertion point past the <a> element, otherwise FireFox inserts inside the <a>\n// With this change, both FireFox and Chrome behave the same way!\nreturn d.getSelectionElement().tagName&&\"a\"===d.getSelectionElement().tagName.toLowerCase()&&d.setSelectionAfterElement(d.getSelectionElement()),this.$editor().wrapSelection(\"insertHTML\",g,!0)}},onElementSelect:{element:\"img\",onlyWithAttrs:[\"ta-insert-video\"],action:e.imgOnSelectAction}}),a(\"insertLink\",{tooltiptext:c.insertLink.tooltip,iconclass:\"fa fa-link\",action:function(){var a;if(\n// if this link has already been set, we need to just edit the existing link\n/* istanbul ignore if: we do not test this */\na=d.getSelectionElement().tagName&&\"a\"===d.getSelectionElement().tagName.toLowerCase()?b.prompt(c.insertLink.dialogPrompt,d.getSelectionElement().href):b.prompt(c.insertLink.dialogPrompt,\"http://\"),a&&\"\"!==a&&\"http://\"!==a&&!l(a))return this.$editor().wrapSelection(\"createLink\",a,!0)},activeState:function(a){return!!a&&\"A\"===a[0].tagName},onElementSelect:{element:\"a\",action:e.aOnSelectAction}}),a(\"wordcount\",{display:'<div id=\"toolbarWC\" style=\"display:block; min-width:100px;\">Words: <span ng-bind=\"wordcount\"></span></div>',disabled:!0,wordcount:0,activeState:function(){// this fires on keyup\nvar a=this.$editor().displayElements.text,b=a[0].innerHTML||\"\",c=0;/* istanbul ignore if: will default to '' when undefined */\n//Set current scope\n//Set editor scope\nreturn\"\"!==b.replace(/\\s*<[^>]*?>\\s*/g,\"\")&&\"\"!==b.trim()&&(c=b.replace(/<\\/?(b|i|em|strong|span|u|strikethrough|a|img|small|sub|sup|label)( [^>*?])?>/gi,\"\").replace(/(<[^>]*?>\\s*<[^>]*?>)/gi,\" \").replace(/(<[^>]*?>)/gi,\"\").replace(/\\s+/gi,\" \").match(/\\S+/g).length),this.wordcount=c,this.$editor().wordcount=c,!1}}),a(\"charcount\",{display:'<div id=\"toolbarCC\" style=\"display:block; min-width:120px;\">Characters: <span ng-bind=\"charcount\"></span></div>',disabled:!0,charcount:0,activeState:function(){// this fires on keyup\nvar a=this.$editor().displayElements.text,b=a[0].innerText||a[0].textContent,c=b.replace(/(\\r\\n|\\n|\\r)/gm,\"\").replace(/^\\s+/g,\" \").replace(/\\s+$/g,\" \").length;\n//Set current scope\n//Set editor scope\nreturn this.charcount=c,this.$editor().charcount=c,!1}})}]);// NOTE: textAngularVersion must match the Gruntfile.js 'setVersion' task.... and have format v/d+./d+./d+\nvar f=\"v1.5.16\",g={ie:function(){for(var a,b=3,c=document.createElement(\"div\"),d=c.getElementsByTagName(\"i\");c.innerHTML=\"<!--[if gt IE \"+ ++b+\"]><i></i><![endif]-->\",d[0];);return b>4?b:a}(),webkit:/AppleWebKit\\/([\\d.]+)/i.test(navigator.userAgent),isFirefox:navigator.userAgent.toLowerCase().indexOf(\"firefox\")>-1},h=h||{};/* istanbul ignore next: untestable browser check */\nh.now=function(){return h.now||h.mozNow||h.msNow||h.oNow||h.webkitNow||function(){return(new Date).getTime()}}();\n// Global to textAngular REGEXP vars for block and list elements.\nvar i=/^(address|article|aside|audio|blockquote|canvas|center|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video)$/i,j=/^(ul|li|ol)$/i,k=/^(#text|span|address|article|aside|audio|blockquote|canvas|center|dd|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|noscript|ol|output|p|pre|section|table|tfoot|ul|video|li)$/i;\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Compatibility\n/* istanbul ignore next: trim shim for older browsers */\nString.prototype.trim||(String.prototype.trim=function(){return this.replace(/^\\s+|\\s+$/g,\"\")});/*\n\tCustom stylesheet for the placeholders rules.\n\tCredit to: http://davidwalsh.name/add-rules-stylesheets\n*/\nvar l,m,n,o,p,q;/* istanbul ignore else: IE <8 test*/\nif(g.ie>8||void 0===g.ie){/* istanbul ignore next: preference for stylesheet loaded externally */\nfor(var r=document.styleSheets,s=0;s<r.length;s++)if((0===r[s].media.length||r[s].media.mediaText.match(/(all|screen)/gi))&&r[s].href&&r[s].href.match(/textangular\\.(min\\.|)css/gi)){l=r[s];break}/* istanbul ignore next: preference for stylesheet loaded externally */\nl||(\n// this sheet is used for the placeholders later on.\nl=function(){\n// Create the <style> tag\nvar a=document.createElement(\"style\");/* istanbul ignore else : WebKit hack :( */\n// Add the <style> element to the page, add as first so the styles can be overridden by custom stylesheets\nreturn g.webkit&&a.appendChild(document.createTextNode(\"\")),document.getElementsByTagName(\"head\")[0].appendChild(a),a.sheet}()),\n// use as: addCSSRule(\"header\", \"float: left\");\nm=function(a,b){return o(l,a,b)},o=function(a,b,c){var d,e;\n// return the inserted stylesheet rule\n// This order is important as IE 11 has both cssRules and rules but they have different lengths - cssRules is correct, rules gives an error in IE 11\n/* istanbul ignore next: browser catches */\n/* istanbul ignore else: untestable IE option */\n/* istanbul ignore next: browser catches */\nreturn a.cssRules?d=Math.max(a.cssRules.length-1,0):a.rules&&(d=Math.max(a.rules.length-1,0)),a.insertRule?a.insertRule(b+\"{\"+c+\"}\",d):a.addRule(b,c,d),l.rules?e=l.rules[d]:l.cssRules&&(e=l.cssRules[d]),e},q=function(a,b){var c,d;for(c=0;c<b.length;c++)/* istanbul ignore else: check for correct rule */\nif(b[c].cssText===a.cssText){d=c;break}return d},n=function(a){p(l,a)},/* istanbul ignore next: tests are browser specific */\np=function(a,b){var c=a.cssRules||a.rules;if(c&&0!==c.length){var d=q(b,c);a.removeRule?a.removeRule(d):a.deleteRule(d)}}}angular.module(\"textAngular.factories\",[]).factory(\"taBrowserTag\",[function(){return function(a){/* istanbul ignore next: ie specific test */\n/* istanbul ignore next: ie specific test */\nreturn a?\"\"===a?void 0===g.ie?\"div\":g.ie<=8?\"P\":\"p\":g.ie<=8?a.toUpperCase():a:g.ie<=8?\"P\":\"p\"}}]).factory(\"taApplyCustomRenderers\",[\"taCustomRenderers\",\"taDOM\",function(a,b){return function(c){var d=angular.element(\"<div></div>\");return d[0].innerHTML=c,angular.forEach(a,function(a){var c=[];\n// get elements based on what is defined. If both defined do secondary filter in the forEach after using selector string\na.selector&&\"\"!==a.selector?c=d.find(a.selector):a.customAttribute&&\"\"!==a.customAttribute&&(c=b.getByAttribute(d,a.customAttribute)),\n// process elements if any found\nangular.forEach(c,function(b){b=angular.element(b),a.selector&&\"\"!==a.selector&&a.customAttribute&&\"\"!==a.customAttribute?void 0!==b.attr(a.customAttribute)&&a.renderLogic(b):a.renderLogic(b)})}),d[0].innerHTML}}]).factory(\"taFixChrome\",function(){\n// get whaterever rubbish is inserted in chrome\n// should be passed an html string, returns an html string\nvar a=function(a,b){if(!a||!angular.isString(a)||a.length<=0)return a;\n// remove all the Apple-converted-space spans and replace with the content of the span\n//console.log('before:', html);\n/* istanbul ignore next: apple-contereted-space span match */\nfor(\n// grab all elements with a style attibute\n// a betterSpanMatch matches only a style=... with matching quotes\n// this captures the whole:\n// 'style=\"background-color: rgb(255, 255, 255);\"'\nvar c,d,e,f=/style\\s?=\\s?([\"'])(?:(?=(\\\\?))\\2.)*?\\1/gi,g=/<span class=\"Apple-converted-space\">([^<]+)<\\/span>/gi,h=\"\",i=0;c=g.exec(a);)e=c[1],e=e.replace(/&nbsp;/gi,\" \"),h+=a.substring(i,c.index)+e,i=c.index+c[0].length;\n/////////////////////////////////////////////////////////////\n//\n// Allow control of this modification\n// taKeepStyles: False - removes these modification\n//\n// taFixChrome removes the following styles:\n//    font-family: inherit;\n//    line-height: <number>\n//    color: inherit;\n//    color: rgb( <rgb-component>#{3} )\n//    background-color: rgb( <rgb-component>#{3} )\n//\n/////////////////////////////////////////////////////////////\nif(/* istanbul ignore next: apple-contereted-space span has matched */\ni&&(\n// modified....\nh+=a.substring(i),a=h,h=\"\",i=0),!b){for(;c=f.exec(a);)h+=a.substring(i,c.index-1),d=c[0],\n// test for chrome inserted junk\nc=/font-family: inherit;|line-height: 1.[0-9]{3,12};|color: inherit; line-height: 1.1;|color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);|background-color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);/gi.exec(d),c?(d=d.replace(/( |)font-family: inherit;|( |)line-height: 1.[0-9]{3,12};|( |)color: inherit;|( |)color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);|( |)background-color: rgb\\(\\d{1,3}, \\d{1,3}, \\d{1,3}\\);/gi,\"\"),\n//console.log(styleVal, styleVal.length);\nd.length>8&&(h+=\" \"+d)):h+=\" \"+d,i=f.lastIndex;h+=a.substring(i)}\n//console.log('final:', finalHtml);\n// only replace when something has changed, else we get focus problems on inserting lists\nif(i>0){\n// replace all empty strings\nvar j=h.replace(/<span\\s?>(.*?)<\\/span>(<br(\\/|)>|)/gi,\"$1\");return j}return a};return a}).factory(\"taSanitize\",[\"$sanitize\",function(a){function b(a,b){for(var c,d=0,e=0,f=/<[^>]*>/gi;c=f.exec(a);)if(e=c.index,\"/\"===c[0].substr(1,1)){if(0===d)break;d--}else d++;\n// get the start tags reversed - this is safe as we construct the strings with no content except the tags\nreturn b+a.substring(0,e)+angular.element(b)[0].outerHTML.substring(b.length)+a.substring(e)}function c(a){if(!a||!angular.isString(a)||a.length<=0)return a;for(var d,f,g,h,i,k,l=/<([^>\\/]+?)style=(\"([^\"]+)\"|'([^']+)')([^>]*)>/gi,m=\"\",n=\"\",o=0;f=l.exec(a);){\n// one of the quoted values ' or \"\n/* istanbul ignore next: quotations match */\nh=f[3]||f[4];var p=new RegExp(j,\"i\");\n// test for style values to change\nif(angular.isString(h)&&p.test(h)){\n// remove build tag list\ni=\"\";\n// find relevand tags and build a string of them\nfor(\n// init regex here for exec\nvar q=new RegExp(j,\"ig\");g=q.exec(h);)for(d=0;d<e.length;d++)g[2*d+2]&&(i+=\"<\"+e[d].tag+\">\");\n// recursively find more legacy styles in html before this tag and after the previous match (if any)\nk=c(a.substring(o,f.index)),\n// build up html\nn+=m.length>0?b(k,m):k,\n// grab the style val without the transformed values\nh=h.replace(new RegExp(j,\"ig\"),\"\"),\n// build the html tag\nn+=\"<\"+f[1].trim(),h.length>0&&(n+=' style=\"'+h+'\"'),n+=f[5]+\">\",\n// update the start index to after this tag\no=f.index+f[0].length,m=i}}return n+=m.length>0?b(a.substring(o),m):a.substring(o)}function d(a){if(!a||!angular.isString(a)||a.length<=0)return a;\n// match all attr tags\nfor(\n// replace all align='...' tags with text-align attributes\nvar b,c=/<([^>\\/]+?)align=(\"([^\"]+)\"|'([^']+)')([^>]*)>/gi,d=\"\",e=0;b=c.exec(a);){\n// add all html before this tag\nd+=a.substring(e,b.index),\n// record last index after this tag\ne=b.index+b[0].length;\n// construct tag without the align attribute\nvar f=\"<\"+b[1]+b[5];\n// add the style attribute\n/style=(\"([^\"]+)\"|'([^']+)')/gi.test(f)?/* istanbul ignore next: quotations match */\nf=f.replace(/style=(\"([^\"]+)\"|'([^']+)')/i,'style=\"$2$3 text-align:'+(b[3]||b[4])+';\"'):/* istanbul ignore next: quotations match */\nf+=' style=\"text-align:'+(b[3]||b[4])+';\"',f+=\">\",\n// add to html\nd+=f}\n// return with remaining html\nreturn d+a.substring(e)}for(var e=[{property:\"font-weight\",values:[\"bold\"],tag:\"b\"},{property:\"font-style\",values:[\"italic\"],tag:\"i\"}],f=[],g=0;g<e.length;g++){for(var h=\"(\"+e[g].property+\":\\\\s*(\",i=0;i<e[g].values.length;i++)/* istanbul ignore next: not needed to be tested yet */\ni>0&&(h+=\"|\"),h+=e[g].values[i];h+=\");)\",f.push(h)}var j=\"(\"+f.join(\"|\")+\")\",k=new RegExp(/<span id=\"selectionBoundary_\\d+_\\d+\" class=\"rangySelectionBoundary\">[^<>]+?<\\/span>/gi),l=new RegExp(/<span class=\"rangySelectionBoundary\" id=\"selectionBoundary_\\d+_\\d+\">[^<>]+?<\\/span>/gi),m=new RegExp(/<span id=\"selectionBoundary_\\d+_\\d+\" class=\"rangySelectionBoundary\">[^<>]+?<\\/span>/gi);return function(b,e,f){\n// unsafe html should NEVER built into a DOM object via angular.element. This allows XSS to be inserted and run.\nif(!f)try{b=c(b)}catch(a){}\n// we had an issue in the past, where we dumped a whole bunch of <span>'s into the content...\n// so we remove them here\n// IN A FUTURE release this can be removed after all have updated through release 1.5.9\nif(\n// unsafe and oldsafe should be valid HTML strings\n// any exceptions (lets say, color for example) should be made here but with great care\n// setup unsafe element for modification\nb=d(b))try{b=b.replace(k,\"\"),b=b.replace(l,\"\"),b=b.replace(k,\"\"),b=b.replace(m,\"\")}catch(a){}var g;try{g=a(b),\n// do this afterwards, then the $sanitizer should still throw for bad markup\nf&&(g=b)}catch(a){g=e||\"\"}\n// Do processing for <pre> tags, removing tabs and return carriages outside of them\nvar h,i=g.match(/(<pre[^>]*>.*?<\\/pre[^>]*>)/gi),j=g.replace(/(&#(9|10);)*/gi,\"\"),n=/<pre[^>]*>.*?<\\/pre[^>]*>/gi,o=0,p=0;for(g=\"\";null!==(h=n.exec(j))&&o<i.length;)g+=j.substring(p,h.index)+i[o],p=h.index+h[0].length,o++;return g+j.substring(p)}}]).factory(\"taToolExecuteAction\",[\"$q\",\"$log\",function(a,b){\n// this must be called on a toolScope or instance\nreturn function(c){void 0!==c&&(this.$editor=function(){return c});var d,e=a.defer(),f=e.promise,g=this.$editor();try{d=this.action(e,g.startAction()),\n// We set the .finally callback here to make sure it doesn't get executed before any other .then callback.\nf.finally(function(){g.endAction.call(g)})}catch(a){b.error(a)}(d||void 0===d)&&\n// if true or undefined is returned then the action has finished. Otherwise the deferred action will be resolved manually.\ne.resolve()}}]),angular.module(\"textAngular.DOM\",[\"textAngular.factories\"]).factory(\"taExecCommand\",[\"taSelection\",\"taBrowserTag\",\"$document\",function(b,c,d){var e=function(a,c){var d,e,f=a.find(\"li\");for(e=f.length-1;e>=0;e--)d=angular.element(\"<\"+c+\">\"+f[e].innerHTML+\"</\"+c+\">\"),a.after(d);a.remove(),b.setSelectionToElementEnd(d[0])},f=function(a,d,e,f,g){var h,i,j,k,l,m=a.find(\"li\");for(i=0;i<m.length;i++)if(m[i].outerHTML===d[0].outerHTML){\n// found it...\nl=i,i>0&&(j=m[i-1]),i+1<m.length&&(k=m[i+1]);break}\n//console.log('listElementToSelfTag', list, listElement, selfTag, bDefault, priorElement, nextElement);\n// un-list the listElement\nvar n=\"\";\n//console.log('$target', $target[0]);\nif(f?n+=\"<\"+g+\">\"+d[0].innerHTML+\"</\"+g+\">\":(n+=\"<\"+c(e)+\">\",n+=\"<li>\"+d[0].innerHTML+\"</li>\",n+=\"</\"+c(e)+\">\"),h=angular.element(n),!j)\n// this is the first the list, so we just remove it...\nreturn d.remove(),a.after(angular.element(a[0].outerHTML)),a.after(h),a.remove(),void b.setSelectionToElementEnd(h[0]);if(k){var o=(a.parent(),\"\"),p=a[0].nodeName.toLowerCase();for(o+=\"<\"+p+\">\",i=0;i<l;i++)o+=\"<li>\"+m[i].innerHTML+\"</li>\";o+=\"</\"+p+\">\";var q=\"\";for(q+=\"<\"+p+\">\",i=l+1;i<m.length;i++)q+=\"<li>\"+m[i].innerHTML+\"</li>\";q+=\"</\"+p+\">\",\n//console.log(html1, $target[0], html2);\na.after(angular.element(q)),a.after(h),a.after(angular.element(o)),a.remove(),\n//console.log('parent ******XXX*****', p[0]);\nb.setSelectionToElementEnd(h[0])}else\n// this is the last in the list, so we just remove it..\nd.remove(),a.after(h),b.setSelectionToElementEnd(h[0])},g=function(a,d,e,f,g){var h,i,j,k,l,m=a.find(\"li\"),n=[];for(i=0;i<m.length;i++)for(j=0;j<d.length;j++)m[i].isEqualNode(d[j])&&(\n// found it...\nn[j]=i);n[0]>0&&(k=m[n[0]-1]),n[d.length-1]+1<m.length&&(l=m[n[d.length-1]+1]);\n//console.log('listElementsToSelfTag', list, listElements, selfTag, bDefault, !priorElement, !afterElement, foundIndexes[listElements.length-1], children.length);\n// un-list the listElements\nvar o=\"\";if(f)for(j=0;j<d.length;j++)o+=\"<\"+g+\">\"+d[j].innerHTML+\"</\"+g+\">\",d[j].remove();else{for(o+=\"<\"+c(e)+\">\",j=0;j<d.length;j++)o+=d[j].outerHTML,d[j].remove();o+=\"</\"+c(e)+\">\"}if(h=angular.element(o),!k)\n// this is the first the list, so we just remove it...\nreturn a.after(angular.element(a[0].outerHTML)),a.after(h),a.remove(),void b.setSelectionToElementEnd(h[0]);if(!l)\n// this is the last in the list, so we just remove it..\nreturn a.after(h),void b.setSelectionToElementEnd(h[0]);\n// okay it was some where in the middle... so we need to break apart the list...\nvar p=\"\",q=a[0].nodeName.toLowerCase();for(p+=\"<\"+q+\">\",i=0;i<n[0];i++)p+=\"<li>\"+m[i].innerHTML+\"</li>\";p+=\"</\"+q+\">\";var r=\"\";for(r+=\"<\"+q+\">\",i=n[d.length-1]+1;i<m.length;i++)r+=\"<li>\"+m[i].innerHTML+\"</li>\";r+=\"</\"+q+\">\",a.after(angular.element(r)),a.after(h),a.after(angular.element(p)),a.remove(),\n//console.log('parent ******YYY*****', list.parent()[0]);\nb.setSelectionToElementEnd(h[0])},h=function(a){/(<br(|\\/)>)$/i.test(a.innerHTML.trim())?b.setSelectionBeforeElement(angular.element(a).find(\"br\")[0]):b.setSelectionToElementEnd(a)},k=function(a,b){var c=angular.element(\"<\"+b+\">\"+a[0].innerHTML+\"</\"+b+\">\");a.after(c),a.remove(),h(c.find(\"li\")[0])},l=function(a,b,d){for(var e=\"\",f=0;f<a.length;f++)e+=\"<\"+c(\"li\")+\">\"+a[f].innerHTML+\"</\"+c(\"li\")+\">\";var g=angular.element(\"<\"+d+\">\"+e+\"</\"+d+\">\");b.after(g),b.remove(),h(g.find(\"li\")[0])},m=function(a,b){for(var c=0;c<a.childNodes.length;c++){var d=a.childNodes[c];/* istanbul ignore next - more complex testing*/\nd.tagName&&d.tagName.match(i)&&m(d,b)}/* istanbul ignore next - very rare condition that we do not test*/\nif(null===a.parentNode)\n// nothing left to do..\nreturn a;/* istanbul ignore next - not sure have to test this */\nif(\"<br>\"===b)return a;var e=angular.element(b);return e[0].innerHTML=a.innerHTML,a.parentNode.insertBefore(e[0],a),a.parentNode.removeChild(a),e};return function(h,n){\n// NOTE: here we are dealing with the html directly from the browser and not the html the user sees.\n// IF you want to modify the html the user sees, do it when the user does a switchView\nreturn h=c(h),function(o,p,q,r){var s,t,u,v,w,x,y,z,A=angular.element(\"<\"+h+\">\");try{b.getSelection&&(z=b.getSelection()),y=b.getSelectionElement();\n// special checks and fixes when we are selecting the whole container\nvar B,C;/* istanbul ignore next */\nvoid 0!==y.tagName&&(\"div\"===y.tagName.toLowerCase()&&/taTextElement.+/.test(y.id)&&z&&z.start&&1===z.start.offset&&1===z.end.offset?(\n// opps we are actually selecting the whole container!\n//console.log('selecting whole container!');\nB=y.innerHTML,/<br>/i.test(B)&&(\n// Firefox adds <br>'s and so we remove the <br>\nB=B.replace(/<br>/i,\"&#8203;\")),/<br\\/>/i.test(B)&&(\n// Firefox adds <br/>'s and so we remove the <br/>\nB=B.replace(/<br\\/>/i,\"&#8203;\")),\n// remove stacked up <span>'s\n/<span>(<span>)+/i.test(B)&&(B=__.replace(/<span>(<span>)+/i,\"<span>\")),\n// remove stacked up </span>'s\n/<\\/span>(<\\/span>)+/i.test(B)&&(B=__.replace(/<\\/span>(<\\/span>)+/i,\"</span>\")),/<span><\\/span>/i.test(B)&&(\n// if we end up with a <span></span> here we remove it...\nB=B.replace(/<span><\\/span>/i,\"\")),\n//console.log('inner whole container', selectedElement.childNodes);\nC=\"<div>\"+B+\"</div>\",y.innerHTML=C,b.setSelectionToElementEnd(y.childNodes[0]),y=b.getSelectionElement()):\"span\"===y.tagName.toLowerCase()&&z&&z.start&&1===z.start.offset&&1===z.end.offset?(\n// just a span -- this is a problem...\n//console.log('selecting span!');\nB=y.innerHTML,/<br>/i.test(B)&&(\n// Firefox adds <br>'s and so we remove the <br>\nB=B.replace(/<br>/i,\"&#8203;\")),/<br\\/>/i.test(B)&&(\n// Firefox adds <br/>'s and so we remove the <br/>\nB=B.replace(/<br\\/>/i,\"&#8203;\")),\n// remove stacked up <span>'s\n/<span>(<span>)+/i.test(B)&&(B=__.replace(/<span>(<span>)+/i,\"<span>\")),\n// remove stacked up </span>'s\n/<\\/span>(<\\/span>)+/i.test(B)&&(B=__.replace(/<\\/span>(<\\/span>)+/i,\"</span>\")),/<span><\\/span>/i.test(B)&&(\n// if we end up with a <span></span> here we remove it...\nB=B.replace(/<span><\\/span>/i,\"\")),\n//console.log('inner span', selectedElement.childNodes);\n// we wrap this in a <div> because otherwise the browser get confused when we attempt to select the whole node\n// and the focus is not set correctly no matter what we do\nC=\"<div>\"+B+\"</div>\",y.innerHTML=C,b.setSelectionToElementEnd(y.childNodes[0]),y=b.getSelectionElement()):\"p\"===y.tagName.toLowerCase()&&z&&z.start&&1===z.start.offset&&1===z.end.offset?(\n//console.log('p special');\n// we need to remove the </br> that firefox adds!\nB=y.innerHTML,/<br>/i.test(B)&&(\n// Firefox adds <br>'s and so we remove the <br>\nB=B.replace(/<br>/i,\"&#8203;\"),// no space-space\ny.innerHTML=B)):\"li\"===y.tagName.toLowerCase()&&z&&z.start&&z.start.offset===z.end.offset&&(\n// we need to remove the </br> that firefox adds!\nB=y.innerHTML,/<br>/i.test(B)&&(\n// Firefox adds <br>'s and so we remove the <br>\nB=B.replace(/<br>/i,\"\"),// nothing\ny.innerHTML=B)))}catch(a){}\n//console.log('************** selectedElement:', selectedElement);\n/* istanbul ignore if: */\nif(y){var D=angular.element(y),E=y&&y.tagName&&y.tagName.toLowerCase()||/* istanbul ignore next: */\n\"\";if(\"insertorderedlist\"===o.toLowerCase()||\"insertunorderedlist\"===o.toLowerCase()){var F=c(\"insertorderedlist\"===o.toLowerCase()?\"ol\":\"ul\"),G=b.getOnlySelectedElements();\n//console.log('PPPPPPPPPPPPP', tagName, selfTag, selectedElements, tagName.match(BLOCKELEMENTS), $selected.hasClass('ta-bind'), $selected.parent()[0].tagName);\nif(G.length>1&&(\"ol\"===E||\"ul\"===E))return g(D,G,F,F===E,h);if(E===F)\n// if all selected then we should remove the list\n// grab all li elements and convert to taDefaultWrap tags\n//console.log('tagName===selfTag');\n// if all selected then we should remove the list\n// grab all li elements and convert to taDefaultWrap tags\n//console.log('tagName===selfTag');\nreturn D[0].childNodes.length!==G.length&&1===G.length?(D=angular.element(G[0]),f(D.parent(),D,F,!0,h)):e(D,h);if(\"li\"===E&&D.parent()[0].tagName.toLowerCase()===F&&1===D.parent().children().length)\n// catch for the previous statement if only one li exists\nreturn e(D.parent(),h);if(\"li\"===E&&D.parent()[0].tagName.toLowerCase()!==F&&1===D.parent().children().length)\n// catch for the previous statement if only one li exists\nreturn k(D.parent(),F);if(E.match(i)&&!D.hasClass(\"ta-bind\")){\n// if it's one of those block elements we have to change the contents\n// if it's a ol/ul we are changing from one to the other\nif(G.length&&D[0].childNodes.length!==G.length&&1===G.length)\n//console.log('&&&&&&&&&&&&&&& --------- &&&&&&&&&&&&&&&&', selectedElements[0], $selected[0].childNodes);\nreturn D=angular.element(G[0]),f(D.parent(),D,F,F===E,h);if(\"ol\"===E||\"ul\"===E)\n// now if this is a set of selected elements... behave diferently\nreturn k(D,F);var H=!1;return angular.forEach(D.children(),function(a){a.tagName.match(i)&&(H=!0)}),H?l(D.children(),D,F):l([angular.element(\"<div>\"+y.innerHTML+\"</div>\")[0]],D,F)}if(E.match(i)){\n//console.log('_nodes', _nodes, tagName);\nif(\n// if we get here then the contents of the ta-bind are selected\nv=b.getOnlySelectedElements(),0===v.length)\n// here is if there is only text in ta-bind ie <div ta-bind>test content</div>\nt=angular.element(\"<\"+F+\"><li>\"+y.innerHTML+\"</li></\"+F+\">\"),D.html(\"\"),D.append(t);else{if(1===v.length&&(\"ol\"===v[0].tagName.toLowerCase()||\"ul\"===v[0].tagName.toLowerCase()))return v[0].tagName.toLowerCase()===F?e(angular.element(v[0]),h):k(angular.element(v[0]),F);u=\"\";var I=[];for(s=0;s<v.length;s++)/* istanbul ignore else: catch for real-world can't make it occur in testing */\nif(3!==v[s].nodeType){var J=angular.element(v[s]);/* istanbul ignore if: browser check only, phantomjs doesn't return children nodes but chrome at least does */\nif(\"li\"===v[s].tagName.toLowerCase())continue;u+=\"ol\"===v[s].tagName.toLowerCase()||\"ul\"===v[s].tagName.toLowerCase()?J[0].innerHTML:\"span\"!==v[s].tagName.toLowerCase()||\"ol\"!==v[s].childNodes[0].tagName.toLowerCase()&&\"ul\"!==v[s].childNodes[0].tagName.toLowerCase()?\"<\"+c(\"li\")+\">\"+J[0].innerHTML+\"</\"+c(\"li\")+\">\":J[0].childNodes[0].innerHTML,I.unshift(J)}\n//console.log('$nodes', $nodes);\nt=angular.element(\"<\"+F+\">\"+u+\"</\"+F+\">\"),I.pop().replaceWith(t),angular.forEach(I,function(a){a.remove()})}return void b.setSelectionToElementEnd(t[0])}}else{if(\"formatblock\"===o.toLowerCase()){\n// find the first blockElement\nfor(x=q.toLowerCase().replace(/[<>]/gi,\"\"),\"default\"===x.trim()&&(x=h,q=\"<\"+h+\">\"),t=\"li\"===E?D.parent():D;!t[0].tagName||!t[0].tagName.match(i)&&!t.parent().attr(\"contenteditable\");)t=t.parent(),/* istanbul ignore next */\nE=(t[0].tagName||\"\").toLowerCase();if(E===x){\n// $target is wrap element\nv=t.children();var K=!1;for(s=0;s<v.length;s++)K=K||v[s].tagName.match(i);K?(t.after(v),w=t.next(),t.remove(),t=w):(A.append(t[0].childNodes),t.after(A),t.remove(),t=A)}else if(t.parent()[0].tagName.toLowerCase()!==x||t.parent().hasClass(\"ta-bind\"))if(E.match(j))\n// wrapping a list element\nt.wrap(q);else{\n// find the parent block element if any of the nodes are inline or text\nfor(\n// default wrap behaviour\nv=b.getOnlySelectedElements(),0===v.length&&(\n// no nodes at all....\nv=[t[0]]),s=0;s<v.length;s++)if(3===v[s].nodeType||!v[s].tagName.match(i))for(;3===v[s].nodeType||!v[s].tagName||!v[s].tagName.match(i);)v[s]=v[s].parentNode;if(\n// remove any duplicates from the array of _nodes!\nv=v.filter(function(a,b,c){return c.indexOf(a)===b}),\n// remove all whole taTextElement if it is here... unless it is the only element!\nv.length>1&&(v=v.filter(function(a,b,c){return!(\"div\"===a.nodeName.toLowerCase()&&/^taTextElement/.test(a.id))})),angular.element(v[0]).hasClass(\"ta-bind\"))t=angular.element(q),t[0].innerHTML=v[0].innerHTML,v[0].innerHTML=t[0].outerHTML;else if(\"blockquote\"===x){for(\n// blockquotes wrap other block elements\nu=\"\",s=0;s<v.length;s++)u+=v[s].outerHTML;for(t=angular.element(q),t[0].innerHTML=u,v[0].parentNode.insertBefore(t[0],v[0]),s=v.length-1;s>=0;s--)/* istanbul ignore else:  */\nv[s].parentNode&&v[s].parentNode.removeChild(v[s])}else/* istanbul ignore next: not tested since identical to blockquote */\nif(\"pre\"===x&&b.getStateShiftKey()){for(\n//console.log('shift pre', _nodes);\n// pre wrap other block elements\nu=\"\",s=0;s<v.length;s++)u+=v[s].outerHTML;for(t=angular.element(q),t[0].innerHTML=u,v[0].parentNode.insertBefore(t[0],v[0]),s=v.length-1;s>=0;s--)/* istanbul ignore else:  */\nv[s].parentNode&&v[s].parentNode.removeChild(v[s])}else\n//console.log(optionsTagName, _nodes);\n// regular block elements replace other block elements\nfor(s=0;s<v.length;s++){var L=m(v[s],q);v[s]===t[0]&&(t=angular.element(L))}}else{\n//unwrap logic for parent\nvar M=t.parent(),N=M.contents();for(s=0;s<N.length;s++)/* istanbul ignore next: can't test - some wierd thing with how phantomjs works */\nM.parent().hasClass(\"ta-bind\")&&3===N[s].nodeType&&(A=angular.element(\"<\"+h+\">\"),A[0].innerHTML=N[s].outerHTML,N[s]=A[0]),M.parent()[0].insertBefore(N[s],M[0]);M.remove()}\n// looses focus when we have the whole container selected and no text!\n// refocus on the shown display element, this fixes a bug when using firefox\nreturn b.setSelectionToElementEnd(t[0]),void t[0].focus()}if(\"createlink\"===o.toLowerCase()){/* istanbul ignore next: firefox specific fix */\nif(\"a\"===E)\n// already a link!!! we are just replacing it...\nreturn void(b.getSelectionElement().href=q);var O='<a href=\"'+q+'\" target=\"'+(r.a.target?r.a.target:\"\")+'\">',P=\"</a>\",Q=b.getSelection();if(Q.collapsed)\n//console.log('collapsed');\n// insert text at selection, then select then just let normal exec-command run\nb.insertHtml(O+q+P,n);else if(a.getSelection().getRangeAt(0).canSurroundContents()){var R=angular.element(O+P)[0];a.getSelection().getRangeAt(0).surroundContents(R)}return}if(\"inserthtml\"===o.toLowerCase())\n//console.log('inserthtml');\nreturn void b.insertHtml(q,n)}try{d[0].execCommand(o,p,q)}catch(a){}}}}}]).service(\"taSelection\",[\"$document\",\"taDOM\",\"$log\",/* istanbul ignore next: all browser specifics and PhantomJS dosen't seem to support half of it */\nfunction(b,c,d){\n// need to dereference the document else the calls don't work correctly\nvar e,f=b[0],g=function(a,b){/* check if selection is a BR element at the beginning of a container. If so, get\n        * the parentNode instead.\n        * offset should be zero in this case. Otherwise, return the original\n        * element.\n        */\n/* check if selection is a BR element at the beginning of a container. If so, get\n        * the parentNode instead.\n        * offset should be zero in this case. Otherwise, return the original\n        * element.\n        */\nreturn a.tagName&&a.tagName.match(/^br$/i)&&0===b&&!a.previousSibling?{element:a.parentNode,offset:0}:{element:a,offset:b}},h={getSelection:function(){var b;try{\n// catch any errors from rangy and ignore the issue\nb=a.getSelection().getRangeAt(0)}catch(a){\n//console.info(e);\nreturn}var c=b.commonAncestorContainer,d={start:g(b.startContainer,b.startOffset),end:g(b.endContainer,b.endOffset),collapsed:b.collapsed};\n//console.log('***selection container:', selection.container.nodeName, selection.start.offset, selection.container);\n// This has problems under Firefox.\n// On Firefox with\n// <p>Try me !</p>\n// <ul>\n// <li>line 1</li>\n// <li>line 2</li>\n// </ul>\n// <p>line 3</p>\n// <ul>\n// <li>line 4</li>\n// <li>line 5</li>\n// </ul>\n// <p>Hello textAngular</p>\n// WITH the cursor after the 3 on line 3, it gets the commonAncestorContainer as:\n// <TextNode textContent='line 3'>\n// AND Chrome gets the commonAncestorContainer as:\n// <p>line 3</p>\n//\n// Check if the container is a text node and return its parent if so\n// unless this is the whole taTextElement.  If so we return the textNode\n//console.log('*********taTextElement************');\n//console.log('commonAncestorContainer:', container);\nreturn 3===c.nodeType&&(\"div\"===c.parentNode.nodeName.toLowerCase()&&/^taTextElement/.test(c.parentNode.id)||(c=c.parentNode)),\"div\"===c.nodeName.toLowerCase()&&/^taTextElement/.test(c.id)?(d.start.element=c.childNodes[d.start.offset],d.end.element=c.childNodes[d.end.offset],d.container=c):c.parentNode===d.start.element||c.parentNode===d.end.element?d.container=c.parentNode:d.container=c,d},\n// if we use the LEFT_ARROW and we are at the special place <span>&#65279;</span> we move the cursor over by one...\n// Chrome and Firefox behave differently so so fix this for Firefox here.  No adjustment needed for Chrome.\nupdateLeftArrowKey:function(b){var c=a.getSelection().getRangeAt(0);if(c&&c.collapsed){var d=h.getFlattenedDom(c);if(!d.findIndex)return;var e,f,g=c.startContainer,i=d.findIndex(function(a,b){if(a.node===g)return!0;var c=a.parents.indexOf(g);return c!==-1});\n//console.log('updateLeftArrowKey', range.startOffset, range.startContainer.textContent);\n// this first section handles the case for Chrome browser\n// if the first character of the nextNode is a \\ufeff we know that we are just before the special span...\n// and so we most left by one character\nif(\n//console.log('indexStartContainer', indexStartContainer, _nodes.length, 'startContainer:', _node, _node === _nodes[indexStartContainer].node);\nd.forEach(function(a,b){\n//console.log(i, n.node);\na.parents.forEach(function(a,b){})}),i+1<d.length&&(\n// we need the node just after this startContainer\n// so we can check and see it this is a special place\nf=d[i+1].node),f&&f.textContent&&(e=/^\\ufeff([^\\ufeff]*)$/.exec(f.textContent)))\n// we are before the special node with begins with a \\ufeff character\n//console.log('LEFT ...found it...', 'startOffset:', range.startOffset, m[0].length, m[1].length);\n// no need to change anything in this case\nreturn;var j;if(i>0&&(\n// we need the node just after this startContainer\n// so we can check and see it this is a special place\nj=d[i-1].node),0===c.startOffset&&j&&(\n//console.log(nextNodeToLeft, range.startOffset, nextNodeToLeft.textContent);\ne=/^\\ufeff([^\\ufeff]*)$/.exec(j.textContent)))\n//console.log('LEFT &&&&&&&&&&&&&&&&&&&...found it...&&&&&&&&&&&', nextNodeToLeft, m[0].length, m[1].length);\n// move over to the left my one -- Firefox triggers this case\nreturn void h.setSelectionToElementEnd(j)}},\n// if we use the RIGHT_ARROW and we are at the special place <span>&#65279;</span> we move the cursor over by one...\nupdateRightArrowKey:function(a){},getFlattenedDom:function(a){function b(a){if(a.node.childNodes.length){var c=Array.prototype.slice.call(a.node.childNodes);// converts NodeList to Array\nc.forEach(function(c){var d=a.parents.slice();d.slice(-1)[0]!==a.node&&d.push(a.node),b({parents:d,node:c})})}else d.push({parents:a.parents,node:a.node})}var c=a.commonAncestorContainer.parentNode;if(!c)return a.commonAncestorContainer.childNodes;var d=Array.prototype.slice.call(c.childNodes),e=d.indexOf(a.startContainer);\n// make sure that we have a big enough set of nodes\n// now walk the parent\nreturn e+1<d.length&&e>0||c.parentNode&&(c=c.parentNode),d=[],b({parents:[c],node:c}),d},getOnlySelectedElements:function(){var b=a.getSelection().getRangeAt(0),c=b.commonAncestorContainer;\n// get the nodes in the range that are ELEMENT_NODE and are children of the container\n// in this range...\n// Node.TEXT_NODE === 3\n// Node.ELEMENT_NODE === 1\n// Node.COMMENT_NODE === 8\n// Check if the container is a text node and return its parent if so\nreturn c=3===c.nodeType?c.parentNode:c,b.getNodes([1],function(a){return a.parentNode===c})},\n// this includes the container element if all children are selected\ngetAllSelectedElements:function(){var b=a.getSelection().getRangeAt(0),c=b.commonAncestorContainer;\n// Node.TEXT_NODE === 3\n// Node.ELEMENT_NODE === 1\n// Node.COMMENT_NODE === 8\n// Check if the container is a text node and return its parent if so\nc=3===c.nodeType?c.parentNode:c;\n// get the nodes in the range that are ELEMENT_NODE and are children of the container\n// in this range...\nvar d=b.getNodes([1],function(a){return a.parentNode===c}),e=c.innerHTML;\n//console.log(innerHtml);\n//console.log(range.toHtml());\n//console.log(innerHtml === range.toHtml());\nif(\n// remove the junk that rangy has put down\ne=e.replace(/<span id=.selectionBoundary[^>]+>\\ufeff?<\\/span>/gi,\"\"),e===b.toHtml()&&(\"div\"!==c.nodeName.toLowerCase()||!/^taTextElement/.test(c.id))){for(var f=[],g=d.length;g--;f.unshift(d[g]));d=f,d.push(c)}return d},\n// Some basic selection functions\ngetSelectionElement:function(){var a=h.getSelection();return a?h.getSelection().container:void 0},setSelection:function(b,c,d,e){var f=a.createRange();f.setStart(b,d),f.setEnd(c,e),a.getSelection().setSingleRange(f)},setSelectionBeforeElement:function(b){var c=a.createRange();c.selectNode(b),c.collapse(!0),a.getSelection().setSingleRange(c)},setSelectionAfterElement:function(b){var c=a.createRange();c.selectNode(b),c.collapse(!1),a.getSelection().setSingleRange(c)},setSelectionToElementStart:function(b){var c=a.createRange();c.selectNodeContents(b),c.collapse(!0),a.getSelection().setSingleRange(c)},setSelectionToElementEnd:function(b){var c=a.createRange();c.selectNodeContents(b),c.collapse(!1),b.childNodes&&b.childNodes[b.childNodes.length-1]&&\"br\"===b.childNodes[b.childNodes.length-1].nodeName&&(c.startOffset=c.endOffset=c.startOffset-1),a.getSelection().setSingleRange(c)},setStateShiftKey:function(a){e=a},getStateShiftKey:function(){return e},\n// from http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div\n// topNode is the contenteditable normally, all manipulation MUST be inside this.\ninsertHtml:function(b,d){var e,g,j,l,m,n,o,p=angular.element(\"<div>\"+b+\"</div>\"),q=a.getSelection().getRangeAt(0),r=f.createDocumentFragment(),s=p[0].childNodes,t=!0;if(s.length>0){for(\n// NOTE!! We need to do the following:\n// check for blockelements - if they exist then we have to split the current element in half (and all others up to the closest block element) and insert all children in-between.\n// If there are no block elements, or there is a mixture we need to create textNodes for the non wrapped text (we don't want them spans messing up the picture).\nl=[],j=0;j<s.length;j++){var u=s[j];\"p\"===u.nodeName.toLowerCase()&&\"\"===u.innerHTML.trim()||(/****************\n                     *  allow any text to be inserted...\n                    if((   _cnode.nodeType === 3 &&\n                           _cnode.nodeValue === '\\ufeff'[0] &&\n                           _cnode.nodeValue.trim() === '') // empty no-space space element\n                        ) {\n                        // no change to isInline\n                        nodes.push(_cnode);\n                        continue;\n                    }\n                    if(_cnode.nodeType === 3 &&\n                         _cnode.nodeValue.trim() === '') { // empty text node\n                        continue;\n                    }\n                    *****************/\nt=t&&!i.test(u.nodeName),l.push(u))}for(var v=0;v<l.length;v++)n=r.appendChild(l[v]);!t&&q.collapsed&&/^(|<br(|\\/)>)$/i.test(q.startContainer.innerHTML)&&q.selectNode(q.startContainer)}else t=!0,\n// paste text of some sort\nn=r=f.createTextNode(b);\n// Other Edge case - selected data spans multiple blocks.\nif(t)q.deleteContents();else// not inline insert\nif(q.collapsed&&q.startContainer!==d)if(q.startContainer.innerHTML&&q.startContainer.innerHTML.match(/^<[^>]*>$/i))\n// this log is to catch when innerHTML is something like `<img ...>`\ne=q.startContainer,1===q.startOffset?(\n// before single tag\nq.setStartAfter(e),q.setEndAfter(e)):(\n// after single tag\nq.setStartBefore(e),q.setEndBefore(e));else{\n// split element into 2 and insert block element in middle\nif(3===q.startContainer.nodeType&&q.startContainer.parentNode!==d)\n// Escape out of the inline tags like b\nfor(// if text node\ne=q.startContainer.parentNode,g=e.cloneNode(),\n// split the nodes into two lists - before and after, splitting the node with the selection into 2 text nodes.\nc.splitNodes(e.childNodes,e,g,q.startContainer,q.startOffset);!k.test(e.nodeName);){angular.element(e).after(g),e=e.parentNode;var w=g;g=e.cloneNode(),\n// split the nodes into two lists - before and after, splitting the node with the selection into 2 text nodes.\nc.splitNodes(e.childNodes,e,g,w)}else e=q.startContainer,g=e.cloneNode(),c.splitNodes(e.childNodes,e,g,void 0,void 0,q.startOffset);if(angular.element(e).after(g),\n// put cursor to end of inserted content\n//console.log('setStartAfter', parent);\nq.setStartAfter(e),q.setEndAfter(e),/^(|<br(|\\/)>)$/i.test(e.innerHTML.trim())&&(q.setStartBefore(e),q.setEndBefore(e),angular.element(e).remove()),/^(|<br(|\\/)>)$/i.test(g.innerHTML.trim())&&angular.element(g).remove(),\"li\"===e.nodeName.toLowerCase()){for(o=f.createDocumentFragment(),m=0;m<r.childNodes.length;m++)p=angular.element(\"<li>\"),c.transferChildNodes(r.childNodes[m],p[0]),c.transferNodeAttributes(r.childNodes[m],p[0]),o.appendChild(p[0]);r=o,n&&(n=r.childNodes[r.childNodes.length-1],n=n.childNodes[n.childNodes.length-1])}}else q.deleteContents();q.insertNode(r),n&&h.setSelectionToElementEnd(n)}};return h}]).service(\"taDOM\",function(){var a={\n// recursive function that returns an array of angular.elements that have the passed attribute set on them\ngetByAttribute:function(b,c){var d=[],e=b.children();return e.length&&angular.forEach(e,function(b){d=d.concat(a.getByAttribute(angular.element(b),c))}),void 0!==b.attr(c)&&d.push(b),d},transferChildNodes:function(a,b){for(\n// clear out target\nb.innerHTML=\"\";a.childNodes.length>0;)b.appendChild(a.childNodes[0]);return b},splitNodes:function(b,c,d,e,f,g){if(!e&&isNaN(g))throw new Error(\"taDOM.splitNodes requires a splitNode or splitIndex\");for(var h=document.createDocumentFragment(),i=document.createDocumentFragment(),j=0;b.length>0&&(isNaN(g)||g!==j)&&b[0]!==e;)h.appendChild(b[0]),// this removes from the nodes array (if proper childNodes object.\nj++;for(!isNaN(f)&&f>=0&&b[0]&&(h.appendChild(document.createTextNode(b[0].nodeValue.substring(0,f))),b[0].nodeValue=b[0].nodeValue.substring(f));b.length>0;)i.appendChild(b[0]);a.transferChildNodes(h,c),a.transferChildNodes(i,d)},transferNodeAttributes:function(a,b){for(var c=0;c<a.attributes.length;c++)b.setAttribute(a.attributes[c].name,a.attributes[c].value);return b}};return a}),angular.module(\"textAngular.validators\",[]).directive(\"taMaxText\",function(){return{restrict:\"A\",require:\"ngModel\",link:function(a,b,c,d){var e=parseInt(a.$eval(c.taMaxText));if(isNaN(e))throw\"Max text must be an integer\";c.$observe(\"taMaxText\",function(a){if(e=parseInt(a),isNaN(e))throw\"Max text must be an integer\";d.$dirty&&d.$validate()}),d.$validators.taMaxText=function(a){var b=angular.element(\"<div/>\");return b.html(a),b.text().length<=e}}}}).directive(\"taMinText\",function(){return{restrict:\"A\",require:\"ngModel\",link:function(a,b,c,d){var e=parseInt(a.$eval(c.taMinText));if(isNaN(e))throw\"Min text must be an integer\";c.$observe(\"taMinText\",function(a){if(e=parseInt(a),isNaN(e))throw\"Min text must be an integer\";d.$dirty&&d.$validate()}),d.$validators.taMinText=function(a){var b=angular.element(\"<div/>\");return b.html(a),!b.text().length||b.text().length>=e}}}}),angular.module(\"textAngular.taBind\",[\"textAngular.factories\",\"textAngular.DOM\"]).service(\"_taBlankTest\",[function(){return function(a){\n// we radically restructure this code.\n// what was here before was incredibly fragile.\n// What we do now is to check that the html is non-blank visually\n// which we check by looking at html->text\nif(!a)return!0;\n// find first non-tag match - ie start of string or after tag that is not whitespace\n// var t0 = performance.now();\n// Takes a small fraction of a mSec to do this...\nvar b=d(a);\n// var t1 = performance.now();\n// console.log('Took', (t1 - t0).toFixed(4), 'milliseconds to generate:');\n// var t1 = performance.now();\n// console.log('Took', (t1 - t0).toFixed(4), 'milliseconds to generate:');\nreturn\"\"===b&&!/<img[^>]+>/.test(a)}}]).directive(\"taButton\",[function(){return{link:function(a,b,c){b.attr(\"unselectable\",\"on\"),b.on(\"mousedown\",function(a,b){/* istanbul ignore else: this is for catching the jqLite testing*/\n// this prevents focusout from firing on the editor when clicking toolbar buttons\nreturn b&&angular.extend(a,b),a.preventDefault(),!1})}}}]).directive(\"taBind\",[\"taSanitize\",\"$timeout\",\"$document\",\"taFixChrome\",\"taBrowserTag\",\"taSelection\",\"taSelectableElements\",\"taApplyCustomRenderers\",\"taOptions\",\"_taBlankTest\",\"$parse\",\"taDOM\",\"textAngularManager\",function(b,c,d,e,f,h,j,l,o,p,q,r,s){\n// Uses for this are textarea or input with ng-model and ta-bind='text'\n// OR any non-form element with contenteditable=\"contenteditable\" ta-bind=\"html|text\" ng-model\nreturn{priority:2,// So we override validators correctly\nrequire:[\"ngModel\",\"?ngModelOptions\"],link:function(f,r,u,v){function w(a){var b;return V.forEach(function(c){if(c.keyCode===a.keyCode){var d=(a.metaKey?N:0)+(a.ctrlKey?M:0)+(a.shiftKey?P:0)+(a.altKey?O:0);if(c.forbiddenModifiers&d)return;c.mustHaveModifiers.every(function(a){return d&a})&&(b=c.specialKey)}}),b}var x,y,z,A,B=v[0],C=v[1]||{},D=void 0!==r.attr(\"contenteditable\")&&r.attr(\"contenteditable\"),E=D||\"textarea\"===r[0].tagName.toLowerCase()||\"input\"===r[0].tagName.toLowerCase(),F=!1,G=!1,H=!1,I=u.taUnsafeSanitizer||o.disableSanitizer,J=u.taKeepStyles||o.keepStyles,K=/^(9|19|20|27|33|34|35|36|37|38|39|40|45|112|113|114|115|116|117|118|119|120|121|122|123|144|145)$/i,L=/^(8|13|32|46|59|61|107|109|173|186|187|188|189|190|191|192|219|220|221|222)$/i,M=1,N=2,O=4,P=8,Q=13,R=16,S=9,T=37,U=39,V=[\n//\t\tctrl/command + z\n{specialKey:\"UndoKey\",forbiddenModifiers:O+P,mustHaveModifiers:[N+M],keyCode:90},\n//\t\tctrl/command + shift + z\n{specialKey:\"RedoKey\",forbiddenModifiers:O,mustHaveModifiers:[N+M,P],keyCode:90},\n//\t\tctrl/command + y\n{specialKey:\"RedoKey\",forbiddenModifiers:O+P,mustHaveModifiers:[N+M],keyCode:89},\n//\t\tTabKey\n{specialKey:\"TabKey\",forbiddenModifiers:N+P+O+M,mustHaveModifiers:[],keyCode:S},\n//\t\tshift + TabKey\n{specialKey:\"ShiftTabKey\",forbiddenModifiers:N+O+M,mustHaveModifiers:[P],keyCode:S}];\n// set the default to be a paragraph value\nvoid 0===u.taDefaultWrap&&(u.taDefaultWrap=\"p\"),/* istanbul ignore next: ie specific test */\n\"\"===u.taDefaultWrap?(z=\"\",A=void 0===g.ie?\"<div><br></div>\":g.ie>=11?\"<p><br></p>\":g.ie<=8?\"<P>&nbsp;</P>\":\"<p>&nbsp;</p>\"):(z=void 0===g.ie||g.ie>=11?\"br\"===u.taDefaultWrap.toLowerCase()?\"<BR><BR>\":\"<\"+u.taDefaultWrap+\"><br></\"+u.taDefaultWrap+\">\":g.ie<=8?\"<\"+u.taDefaultWrap.toUpperCase()+\"></\"+u.taDefaultWrap.toUpperCase()+\">\":\"<\"+u.taDefaultWrap+\"></\"+u.taDefaultWrap+\">\",A=void 0===g.ie||g.ie>=11?\"br\"===u.taDefaultWrap.toLowerCase()?\"<br><br>\":\"<\"+u.taDefaultWrap+\"><br></\"+u.taDefaultWrap+\">\":g.ie<=8?\"<\"+u.taDefaultWrap.toUpperCase()+\">&nbsp;</\"+u.taDefaultWrap.toUpperCase()+\">\":\"<\"+u.taDefaultWrap+\">&nbsp;</\"+u.taDefaultWrap+\">\"),/* istanbul ignore else */\nC.$options||(C.$options={});// ng-model-options support\nvar W=function(a){if(p(a))return a;var b=angular.element(\"<div>\"+a+\"</div>\");\n//console.log('domTest.children().length():', domTest.children().length);\n//console.log('_ensureContentWrapped', domTest.children());\n//console.log(value, attrs.taDefaultWrap);\nif(0===b.children().length)\n// if we have a <br> and the attrs.taDefaultWrap is a <p> we need to remove the <br>\n//value = value.replace(/<br>/i, '');\na=\"<\"+u.taDefaultWrap+\">\"+a+\"</\"+u.taDefaultWrap+\">\";else{var c,d=b[0].childNodes,e=!1;for(c=0;c<d.length&&!(e=d[c].nodeName.toLowerCase().match(i));c++);if(e)for(a=\"\",c=0;c<d.length;c++){var f=d[c],g=f.nodeName.toLowerCase();\n//console.log('node#:', i, 'name:', nodeName);\nif(\"#comment\"===g)a+=\"<!--\"+f.nodeValue+\"-->\";else if(\"#text\"===g){\n// determine if this is all whitespace, if so, we will leave it as it is.\n// otherwise, we will wrap it as it is\nvar h=f.textContent;\n// not pure white space so wrap in <p>...</p> or whatever attrs.taDefaultWrap is set to.\na+=h.trim()?\"<\"+u.taDefaultWrap+\">\"+h+\"</\"+u.taDefaultWrap+\">\":h}else if(g.match(i))a+=f.outerHTML;else{/* istanbul ignore  next: Doesn't seem to trigger on tests */\nvar j=f.outerHTML||f.nodeValue;/* istanbul ignore else: Doesn't seem to trigger on tests, is tested though */\na+=\"\"!==j.trim()?\"<\"+u.taDefaultWrap+\">\"+j+\"</\"+u.taDefaultWrap+\">\":j}}else a=\"<\"+u.taDefaultWrap+\">\"+a+\"</\"+u.taDefaultWrap+\">\"}\n//console.log(value);\nreturn a};u.taPaste&&(y=q(u.taPaste)),r.addClass(\"ta-bind\");var X;f[\"$undoManager\"+(u.id||\"\")]=B.$undoManager={_stack:[],_index:0,_max:1e3,push:function(a){return\"undefined\"==typeof a||null===a||\"undefined\"!=typeof this.current()&&null!==this.current()&&a===this.current()?a:(this._index<this._stack.length-1&&(this._stack=this._stack.slice(0,this._index+1)),this._stack.push(a),X&&c.cancel(X),this._stack.length>this._max&&this._stack.shift(),this._index=this._stack.length-1,a)},undo:function(){return this.setToIndex(this._index-1)},redo:function(){return this.setToIndex(this._index+1)},setToIndex:function(a){if(!(a<0||a>this._stack.length-1))return this._index=a,this.current()},current:function(){return this._stack[this._index]}};\n// in here we are undoing the converts used elsewhere to prevent the < > and & being displayed when they shouldn't in the code.\nvar Y,Z=function(){if(D)return r[0].innerHTML;if(E)return r.val();throw\"textAngular Error: attempting to update non-editable taBind\"},$=function(a){\n// emit the element-select event, pass the element\nreturn f.$emit(\"ta-element-select\",this),a.preventDefault(),!1},_=f[\"reApplyOnSelectorHandlers\"+(u.id||\"\")]=function(){/* istanbul ignore else */\nF||angular.forEach(j,function(a){\n// check we don't apply the handler twice\nr.find(a).off(\"click\",$).on(\"click\",$)})},aa=function(a,b,c){H=c||!1,\"undefined\"!=typeof b&&null!==b||(b=D),// if not contentEditable then the native undo/redo is fine\n\"undefined\"!=typeof a&&null!==a||(a=Z()),p(a)?(\n// this avoids us from tripping the ng-pristine flag if we click in and out with out typing\n\"\"!==B.$viewValue&&B.$setViewValue(\"\"),b&&\"\"!==B.$undoManager.current()&&B.$undoManager.push(\"\")):(_(),B.$viewValue!==a&&(B.$setViewValue(a),b&&B.$undoManager.push(a))),B.$render()},ba=function(a){r[0].innerHTML=a},ca=f[\"$undoTaBind\"+(u.id||\"\")]=function(){/* istanbul ignore else: can't really test it due to all changes being ignored as well in readonly */\nif(!F&&D){var a=B.$undoManager.undo();\"undefined\"!=typeof a&&null!==a&&(ba(a),aa(a,!1),Y&&c.cancel(Y),Y=c(function(){r[0].focus(),h.setSelectionToElementEnd(r[0])},1))}},da=f[\"$redoTaBind\"+(u.id||\"\")]=function(){/* istanbul ignore else: can't really test it due to all changes being ignored as well in readonly */\nif(!F&&D){var a=B.$undoManager.redo();\"undefined\"!=typeof a&&null!==a&&(ba(a),aa(a,!1),/* istanbul ignore next */\nY&&c.cancel(Y),Y=c(function(){r[0].focus(),h.setSelectionToElementEnd(r[0])},1))}};\n//used for updating when inserting wrapped elements\nf[\"updateTaBind\"+(u.id||\"\")]=function(){F||aa(void 0,void 0,!0)};\n// catch DOM XSS via taSanitize\n// Sanitizing both ways is identical\nvar ea=function(a){return B.$oldViewValue=b(e(a,J),B.$oldViewValue,I)};\n//this code is used to update the models when data is entered/deleted\nif(\n// trigger the validation calls\nr.attr(\"required\")&&(B.$validators.required=function(a,b){return!p(a||b)}),\n// parsers trigger from the above keyup function or any other time that the viewValue is updated and parses it for storage in the ngModel\nB.$parsers.push(ea),B.$parsers.unshift(W),\n// because textAngular is bi-directional (which is awesome) we need to also sanitize values going in from the server\nB.$formatters.push(ea),B.$formatters.unshift(W),B.$formatters.unshift(function(a){return B.$undoManager.push(a||\"\")}),E)if(f.events={},D){\n// all the code specific to contenteditable divs\nvar fa=!1,ga=function(a){var d=void 0!==a&&a.match(/content=[\"']*OneNote.File/i);/* istanbul ignore else: don't care if nothing pasted */\n//console.log(text);\nif(a&&a.trim().length){\n// test paste from word/microsoft product\nif(a.match(/class=[\"']*Mso(Normal|List)/i)||a.match(/content=[\"']*Word.Document/i)||a.match(/content=[\"']*OneNote.File/i)){var e=a.match(/<!--StartFragment-->([\\s\\S]*?)<!--EndFragment-->/i);e=e?e[1]:a,e=e.replace(/<o:p>[\\s\\S]*?<\\/o:p>/gi,\"\").replace(/class=([\"']|)MsoNormal([\"']|)/gi,\"\");var g=angular.element(\"<div>\"+e+\"</div>\"),i=angular.element(\"<div></div>\"),j={element:null,lastIndent:[],lastLi:null,isUl:!1};j.lastIndent.peek=function(){var a=this.length;if(a>0)return this[a-1]};for(var k=function(a){j.isUl=a,j.element=angular.element(a?\"<ul>\":\"<ol>\"),j.lastIndent=[],j.lastIndent.peek=function(){var a=this.length;if(a>0)return this[a-1]},j.lastLevelMatch=null},l=0;l<=g[0].childNodes.length;l++)if(g[0].childNodes[l]&&\"#text\"!==g[0].childNodes[l].nodeName){var m=g[0].childNodes[l].tagName.toLowerCase();if(\"p\"===m||\"ul\"===m||\"h1\"===m||\"h2\"===m||\"h3\"===m||\"h4\"===m||\"h5\"===m||\"h6\"===m||\"table\"===m){var n=angular.element(g[0].childNodes[l]),o=(n.attr(\"class\")||\"\").match(/MsoList(Bullet|Number|Paragraph)(CxSp(First|Middle|Last)|)/i);if(o){if(n[0].childNodes.length<2||n[0].childNodes[1].childNodes.length<1)continue;var p=\"bullet\"===o[1].toLowerCase()||\"number\"!==o[1].toLowerCase()&&!(/^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(n[0].childNodes[1].innerHTML)||/^[^0-9a-z<]*[0-9a-z]+[^0-9a-z<>]</i.test(n[0].childNodes[1].childNodes[0].innerHTML)),q=(n.attr(\"style\")||\"\").match(/margin-left:([\\-\\.0-9]*)/i),s=parseFloat(q?q[1]:0),t=(n.attr(\"style\")||\"\").match(/mso-list:l([0-9]+) level([0-9]+) lfo[0-9+]($|;)/i);if(\n// prefers the mso-list syntax\nt&&t[2]&&(s=parseInt(t[2])),t&&(!j.lastLevelMatch||t[1]!==j.lastLevelMatch[1])||!o[3]||\"first\"===o[3].toLowerCase()||null===j.lastIndent.peek()||j.isUl!==p&&j.lastIndent.peek()===s)k(p),i.append(j.element);else if(null!=j.lastIndent.peek()&&j.lastIndent.peek()<s)j.element=angular.element(p?\"<ul>\":\"<ol>\"),j.lastLi.append(j.element);else if(null!=j.lastIndent.peek()&&j.lastIndent.peek()>s){for(;null!=j.lastIndent.peek()&&j.lastIndent.peek()>s;)if(\"li\"!==j.element.parent()[0].tagName.toLowerCase()){if(!/[uo]l/i.test(j.element.parent()[0].tagName.toLowerCase()))// else it's it should be a sibling\nbreak;j.element=j.element.parent(),j.lastIndent.pop()}else j.element=j.element.parent();j.isUl=\"ul\"===j.element[0].tagName.toLowerCase(),p!==j.isUl&&(k(p),i.append(j.element))}j.lastLevelMatch=t,s!==j.lastIndent.peek()&&j.lastIndent.push(s),j.lastLi=angular.element(\"<li>\"),j.element.append(j.lastLi),j.lastLi.html(n.html().replace(/<!(--|)\\[if !supportLists\\](--|)>[\\s\\S]*?<!(--|)\\[endif\\](--|)>/gi,\"\")),n.remove()}else k(!1),i.append(n)}}var u=function(a){a=angular.element(a);for(var b=a[0].childNodes.length-1;b>=0;b--)a.after(a[0].childNodes[b]);a.remove()};angular.forEach(i.find(\"span\"),function(a){a.removeAttribute(\"lang\"),a.attributes.length<=0&&u(a)}),angular.forEach(i.find(\"font\"),u),a=i.html(),d&&(a=i.html()||g.html()),\n// LF characters instead of spaces in some spots and they are replaced by '/n', so we need to just swap them to spaces\na=a.replace(/\\n/g,\" \")}else{if(\n// remove unnecessary chrome insert\na=a.replace(/<(|\\/)meta[^>]*?>/gi,\"\"),a.match(/<[^>]*?(ta-bind)[^>]*?>/)){\n// entire text-angular or ta-bind has been pasted, REMOVE AT ONCE!!\nif(a.match(/<[^>]*?(text-angular)[^>]*?>/)){var v=angular.element(\"<div>\"+a+\"</div>\");v.find(\"textarea\").remove();for(var w=0;w<binds.length;w++){for(var x=binds[w][0].parentNode.parentNode,z=0;z<binds[w][0].childNodes.length;z++)x.parentNode.insertBefore(binds[w][0].childNodes[z],x);x.parentNode.removeChild(x)}a=v.html().replace('<br class=\"Apple-interchange-newline\">',\"\")}}else a.match(/^<span/)&&(\n// in case of pasting only a span - chrome paste, remove them. THis is just some wierd formatting\n// if we remove the '<span class=\"Apple-converted-space\"> </span>' here we destroy the spacing\n// on paste from even ourselves!\na.match(/<span class=(\\\"Apple-converted-space\\\"|\\'Apple-converted-space\\')>.<\\/span>/gi)||(a=a.replace(/<(|\\/)span[^>]*?>/gi,\"\")));\n// Webkit on Apple tags\na=a.replace(/<br class=\"Apple-interchange-newline\"[^>]*?>/gi,\"\").replace(/<span class=\"Apple-converted-space\">( |&nbsp;)<\\/span>/gi,\"&nbsp;\")}/<li(\\s.*)?>/i.test(a)&&/(<ul(\\s.*)?>|<ol(\\s.*)?>).*<li(\\s.*)?>/i.test(a)===!1&&(\n// insert missing parent of li element\na=a.replace(/<li(\\s.*)?>.*<\\/li(\\s.*)?>/i,\"<ul>$&</ul>\")),\n// parse whitespace from plaintext input, starting with preceding spaces that get stripped on paste\na=a.replace(/^[ |\\u00A0]+/gm,function(a){for(var b=\"\",c=0;c<a.length;c++)b+=\"&nbsp;\";return b}).replace(/\\n|\\r\\n|\\r/g,\"<br />\").replace(/\\t/g,\"&nbsp;&nbsp;&nbsp;&nbsp;\"),y&&(a=y(f,{$html:a})||a),\n// turn span vertical-align:super into <sup></sup>\na=a.replace(/<span style=(\"|')([^<]*?)vertical-align\\s*:\\s*super;?([^>]*?)(\"|')>([^<]+?)<\\/span>/g,\"<sup style='$2$3'>$5</sup>\"),a=b(a,\"\",I),\n//console.log('DONE\\n', text);\nh.insertHtml(a,r[0]),c(function(){B.$setViewValue(Z()),fa=!1,r.removeClass(\"processing-paste\")},0)}else fa=!1,r.removeClass(\"processing-paste\")};r.on(\"paste\",f.events.paste=function(b,e){if(/* istanbul ignore else: this is for catching the jqLite testing*/\ne&&angular.extend(b,e),F||fa)return b.stopPropagation(),b.preventDefault(),!1;\n// Code adapted from http://stackoverflow.com/questions/2176861/javascript-get-clipboard-data-on-paste-event-cross-browser/6804718#6804718\nfa=!0,r.addClass(\"processing-paste\");var f,g=(b.originalEvent||b).clipboardData;/* istanbul ignore next: Handle legacy IE paste */\nif(!g&&window.clipboardData&&window.clipboardData.getData)return f=window.clipboardData.getData(\"Text\"),ga(f),b.stopPropagation(),b.preventDefault(),!1;if(g&&g.getData&&g.types.length>0){for(var h=\"\",i=0;i<g.types.length;i++)h+=\" \"+g.types[i];/* istanbul ignore next: browser tests */\nreturn/text\\/html/i.test(h)?f=g.getData(\"text/html\"):/text\\/plain/i.test(h)&&(f=g.getData(\"text/plain\")),ga(f),b.stopPropagation(),b.preventDefault(),!1}// Everything else - empty editdiv and allow browser to paste content into it, then cleanup\nvar j=a.saveSelection(),k=angular.element('<div class=\"ta-hidden-input\" contenteditable=\"true\"></div>');d.find(\"body\").append(k),k[0].focus(),c(function(){\n// restore selection\na.restoreSelection(j),ga(k[0].innerHTML),r[0].focus(),k.remove()},0)}),r.on(\"cut\",f.events.cut=function(a){\n// timeout to next is needed as otherwise the paste/cut event has not finished actually changing the display\nF?a.preventDefault():c(function(){B.$setViewValue(Z())},0)}),r.on(\"keydown\",f.events.keydown=function(a,b){/* istanbul ignore else: this is for catching the jqLite testing*/\nb&&angular.extend(a,b),a.keyCode===R?h.setStateShiftKey(!0):h.setStateShiftKey(!1),a.specialKey=w(a);var c;/* istanbul ignore else: readonly check */\nif(/* istanbul ignore next: difficult to test */\no.keyMappings.forEach(function(b){a.specialKey===b.commandKeyCode&&(\n// taOptions has remapped this binding... so\n// we disable our own\na.specialKey=void 0),b.testForKey(a)&&(c=b.commandKeyCode),\"UndoKey\"!==b.commandKeyCode&&\"RedoKey\"!==b.commandKeyCode||b.enablePropagation||a.preventDefault()}),/* istanbul ignore next: difficult to test */\n\"undefined\"!=typeof c&&(a.specialKey=c),/* istanbul ignore next: difficult to test as can't seem to select */\n\"undefined\"==typeof a.specialKey||\"UndoKey\"===a.specialKey&&\"RedoKey\"===a.specialKey||(a.preventDefault(),s.sendKeyCommand(f,a)),!(F||(\"UndoKey\"===a.specialKey&&(ca(),a.preventDefault()),\"RedoKey\"===a.specialKey&&(da(),a.preventDefault()),a.keyCode!==Q||a.shiftKey||a.ctrlKey||a.metaKey||a.altKey))){var d,e=function(a,b){for(var c=0;c<a.length;c++)if(a[c]===b)return!0;return!1},g=h.getSelectionElement();\n// shifted to nodeName here from tagName since it is more widely supported see: http://stackoverflow.com/questions/4878484/difference-between-tagname-and-nodename\nif(!g.nodeName.match(k))return;var i=angular.element(z),j=[\"blockquote\",\"ul\",\"ol\"];if(e(j,g.parentNode.tagName.toLowerCase())){if(/^<br(|\\/)>$/i.test(g.innerHTML.trim())&&!g.nextSibling){\n// if last element is blank, pull element outside.\nd=angular.element(g);var l=d.parent();l.after(i),d.remove(),0===l.children().length&&l.remove(),h.setSelectionToElementStart(i[0]),a.preventDefault()}/^<[^>]+><br(|\\/)><\\/[^>]+>$/i.test(g.innerHTML.trim())&&(d=angular.element(g),d.after(i),d.remove(),h.setSelectionToElementStart(i[0]),a.preventDefault())}}});var ha;r.on(\"keyup\",f.events.keyup=function(a,b){// clear the ShiftKey state\n/* istanbul ignore next: FF specific bug fix */\nif(/* istanbul ignore else: this is for catching the jqLite testing*/\nb&&angular.extend(a,b),h.setStateShiftKey(!1),a.keyCode===S){var d=h.getSelection();return void(d.start.element===r[0]&&r.children().length&&h.setSelectionToElementStart(r.children()[0]))}if(\n// we do this here during the 'keyup' so that the browser has already moved the slection by one character...\na.keyCode!==T||a.shiftKey||h.updateLeftArrowKey(r),\n// we do this here during the 'keyup' so that the browser has already moved the slection by one character...\na.keyCode!==U||a.shiftKey||h.updateRightArrowKey(r),X&&c.cancel(X),!F&&!K.test(a.keyCode))/* istanbul ignore next: Ignore any _ENTER_KEYCODE that has ctrlKey, metaKey or alKey */\nif(a.keyCode===Q&&(a.ctrlKey||a.metaKey||a.altKey));else{\n// if enter - insert new taDefaultWrap, if shift+enter insert <br/>\nif(\"\"!==z&&\"<BR><BR>\"!==z&&a.keyCode===Q&&!a.ctrlKey&&!a.metaKey&&!a.altKey){for(var e=h.getSelectionElement();!e.nodeName.match(k)&&e!==r[0];)e=e.parentNode;if(a.shiftKey){\n// shift + Enter\nvar f=e.tagName.toLowerCase();\n//console.log('Shift+Enter', selection.tagName, attrs.taDefaultWrap, selection.innerHTML.trim());\n// For an LI: We see: LI p ....<br><br>\n// For a P: We see: P p ....<br><br>\n// on Safari, the browser ignores the Shift+Enter and acts just as an Enter Key\n// For an LI: We see: LI p <br>\n// For a P: We see: P p <br>\nif((f===u.taDefaultWrap||\"li\"===f||\"pre\"===f||\"div\"===f)&&!/.+<br><br>/.test(e.innerHTML.trim())){var g=e.previousSibling;\n//console.log('wrong....', ps);\n// we need to remove this selection and fix the previousSibling up...\ng&&(g.innerHTML=g.innerHTML+\"<br><br>\",angular.element(e).remove(),h.setSelectionToElementEnd(g))}}else\n// new paragraph, br should be caught correctly\n// shifted to nodeName here from tagName since it is more widely supported see: http://stackoverflow.com/questions/4878484/difference-between-tagname-and-nodename\n//console.log('Enter', selection.nodeName, attrs.taDefaultWrap, selection.innerHTML.trim());\nif(e.tagName.toLowerCase()!==u.taDefaultWrap&&\"li\"!==e.nodeName.toLowerCase()&&(\"\"===e.innerHTML.trim()||\"<br>\"===e.innerHTML.trim())){\n// Chrome starts with a <div><br></div> after an EnterKey\n// so we replace this with the _defaultVal\nvar i=angular.element(z);angular.element(e).replaceWith(i),h.setSelectionToElementStart(i[0])}}var j=Z();\"\"===z||\"\"!==j.trim()&&\"<br>\"!==j.trim()?\"<\"!==j.substring(0,1)&&\"\"!==u.taDefaultWrap:(ba(z),h.setSelectionToElementStart(r.children()[0]));var l=x!==a.keyCode&&L.test(a.keyCode);ha&&c.cancel(ha),ha=c(function(){aa(j,l,!0)},C.$options.debounce||400),l||(X=c(function(){B.$undoManager.push(j)},250)),x=a.keyCode}});\n// when there is a change from a spelling correction in the browser, the only\n// change that is seen is a 'input' and the $watch('html') sees nothing... So\n// we added this element.on('input') to catch this change and call the _setViewValue()\n// so the ngModel is updated and all works as it should.\nvar ia;\n// Placeholders not supported on ie 8 and below\nif(r.on(\"input\",function(){Z()!==B.$viewValue&&(\n// we wait a time now to allow the natural $watch('html') to handle this change\n// and then after a 1 second delay, if there is still a difference we will do the\n// _setViewValue() call.\n/* istanbul ignore if: can't test */\nia&&c.cancel(ia),/* istanbul ignore next: cant' test? */\nia=c(function(){var b=a.saveSelection(),c=Z();c!==B.$viewValue&&\n//console.log('_setViewValue');\n//console.log('old:', ngModel.$viewValue);\n//console.log('new:', _val);\naa(c,!0),\n// if the savedSelection marker is gone at this point, we cannot restore the selection!!!\n//console.log('rangy.restoreSelection', ngModel.$viewValue.length, _savedSelection);\n0!==B.$viewValue.length&&a.restoreSelection(b)},1e3))}),r.on(\"blur\",f.events.blur=function(){G=!1,/* istanbul ignore else: if readonly don't update model */\nF?(H=!0,// don't redo the whole thing, just check the placeholder logic\nB.$render()):aa(void 0,void 0,!0)}),u.placeholder&&(g.ie>8||void 0===g.ie)){var ja;if(!u.id)throw\"textAngular Error: An unique ID is required for placeholders to work\";ja=m(\"#\"+u.id+\".placeholder-text:before\",'content: \"'+u.placeholder+'\"'),f.$on(\"$destroy\",function(){n(ja)})}r.on(\"focus\",f.events.focus=function(){G=!0,r.removeClass(\"placeholder-text\"),_()}),r.on(\"mouseup\",f.events.mouseup=function(){var a=h.getSelection();a&&a.start.element===r[0]&&r.children().length&&h.setSelectionToElementStart(r.children()[0])}),\n// prevent propagation on mousedown in editor, see #206\nr.on(\"mousedown\",f.events.mousedown=function(a,b){/* istanbul ignore else: this is for catching the jqLite testing*/\nb&&angular.extend(a,b),a.stopPropagation()})}else{\n// if a textarea or input just add in change and blur handlers, everything else is done by angulars input directive\nr.on(\"change blur\",f.events.change=f.events.blur=function(){F||B.$setViewValue(Z())}),r.on(\"keydown\",f.events.keydown=function(a,b){\n// Reference to http://stackoverflow.com/questions/6140632/how-to-handle-tab-in-textarea\n/* istanbul ignore else: otherwise normal functionality */\nif(/* istanbul ignore else: this is for catching the jqLite testing*/\nb&&angular.extend(a,b),a.keyCode===S){// tab was pressed\n// get caret position/selection\nvar c=this.selectionStart,d=this.selectionEnd,e=r.val();if(a.shiftKey){\n// find \\t\nvar f=e.lastIndexOf(\"\\n\",c),g=e.lastIndexOf(\"\\t\",c);g!==-1&&g>=f&&(\n// set textarea value to: text before caret + tab + text after caret\nr.val(e.substring(0,g)+e.substring(g+1)),\n// put caret at right position again (add one for the tab)\nthis.selectionStart=this.selectionEnd=c-1)}else\n// set textarea value to: text before caret + tab + text after caret\nr.val(e.substring(0,c)+\"\\t\"+e.substring(d)),\n// put caret at right position again (add one for the tab)\nthis.selectionStart=this.selectionEnd=c+1;\n// prevent the focus lose\na.preventDefault()}});var ka=function(a,b){for(var c=\"\",d=0;d<b;d++)c+=a;return c},la=function(a,b,c){for(var d=0;d<a.length;d++)b.call(c,d,a[d])},ma=function(a,b){var c=\"\",d=a.childNodes;\n// tab out and add the <ul> or <ol> html piece\n// now add on the </ol> or </ul> piece\nreturn b++,c+=ka(\"\\t\",b-1)+a.outerHTML.substring(0,4),la(d,function(a,d){/* istanbul ignore next: browser catch */\nvar e=d.nodeName.toLowerCase();/* istanbul ignore next: not tested, and this was original code -- so not wanting to possibly cause an issue, leaving it... */\nreturn\"#comment\"===e?void(c+=\"<!--\"+d.nodeValue+\"-->\"):\"#text\"===e?void(c+=d.textContent):void(d.outerHTML&&(c+=\"ul\"===e||\"ol\"===e?\"\\n\"+ma(d,b):\"\\n\"+ka(\"\\t\",b)+d.outerHTML))}),c+=\"\\n\"+ka(\"\\t\",b-1)+a.outerHTML.substring(a.outerHTML.lastIndexOf(\"<\"))};\n// handle formating of something like:\n// <ol><!--First comment-->\n//  <li>Test Line 1<!--comment test list 1--></li>\n//    <ul><!--comment ul-->\n//      <li>Nested Line 1</li>\n//        <!--comment between nested lines--><li>Nested Line 2</li>\n//    </ul>\n//  <li>Test Line 3</li>\n// </ol>\nB.$formatters.unshift(function(a){\n// tabulate the HTML so it looks nicer\n//\n// first get a list of the nodes...\n// we do this by using the element parser...\n//\n// doing this -- which is simpiler -- breaks our tests...\n//var _nodes=angular.element(htmlValue);\nvar b=angular.element(\"<div>\"+a+\"</div>\")[0].childNodes;\n// do the reformatting of the layout...\nreturn b.length>0&&(a=\"\",la(b,function(b,c){var d=c.nodeName.toLowerCase();/* istanbul ignore next: not tested, and this was original code -- so not wanting to possibly cause an issue, leaving it... */\n// we aready have some content, so drop to a new line\n// okay a set of list stuff we want to reformat in a nested way\nreturn\"#comment\"===d?void(a+=\"<!--\"+c.nodeValue+\"-->\"):\"#text\"===d?void(a+=c.textContent):void(c.outerHTML&&(a.length>0&&(a+=\"\\n\"),a+=\"ul\"===d||\"ol\"===d?\"\"+ma(c,0):\"\"+c.outerHTML))})),a})}var na,oa=function(a,b){\n// emit the drop event, pass the element, preventing should be done elsewhere\nif(/* istanbul ignore else: this is for catching the jqLite testing*/\nb&&angular.extend(a,b),!t&&!F){t=!0;var d;d=a.originalEvent?a.originalEvent.dataTransfer:a.dataTransfer,f.$emit(\"ta-drop-event\",this,a,d),c(function(){t=!1,aa(void 0,void 0,!0)},100)}},pa=!1;\n// changes to the model variable from outside the html/text inputs\nB.$render=function(){/* istanbul ignore if: Catches rogue renders, hard to replicate in tests */\nif(!pa){pa=!0;\n// catch model being null or undefined\nvar a=B.$viewValue||\"\";\n// if the editor isn't focused it needs to be updated, otherwise it's receiving user input\nH||(/* istanbul ignore else: in other cases we don't care */\nD&&G&&(\n// update while focussed\nr.removeClass(\"placeholder-text\"),/* istanbul ignore next: don't know how to test this */\nna&&c.cancel(na),na=c(function(){/* istanbul ignore if: Can't be bothered testing this... */\nG||(r[0].focus(),h.setSelectionToElementEnd(r.children()[r.children().length-1])),na=void 0},1)),D?(\n// blank\nba(\n// WYSIWYG Mode\nu.placeholder?\"\"===a?z:a:\"\"===a?z:a),\n// if in WYSIWYG and readOnly we kill the use of links by clicking\nF?r.off(\"drop\",oa):(_(),r.on(\"drop\",oa))):\"textarea\"!==r[0].tagName.toLowerCase()&&\"input\"!==r[0].tagName.toLowerCase()?\n// make sure the end user can SEE the html code as a display. This is a read-only display element\nba(l(a)):\n// only for input and textarea inputs\nr.val(a)),D&&u.placeholder&&(\"\"===a?G?r.removeClass(\"placeholder-text\"):r.addClass(\"placeholder-text\"):r.removeClass(\"placeholder-text\")),pa=H=!1}},u.taReadonly&&(\n//set initial value\nF=f.$eval(u.taReadonly),F?(r.addClass(\"ta-readonly\"),\n// we changed to readOnly mode (taReadonly='true')\n\"textarea\"!==r[0].tagName.toLowerCase()&&\"input\"!==r[0].tagName.toLowerCase()||r.attr(\"disabled\",\"disabled\"),void 0!==r.attr(\"contenteditable\")&&r.attr(\"contenteditable\")&&r.removeAttr(\"contenteditable\")):(r.removeClass(\"ta-readonly\"),\n// we changed to NOT readOnly mode (taReadonly='false')\n\"textarea\"===r[0].tagName.toLowerCase()||\"input\"===r[0].tagName.toLowerCase()?r.removeAttr(\"disabled\"):D&&r.attr(\"contenteditable\",\"true\")),\n// taReadonly only has an effect if the taBind element is an input or textarea or has contenteditable='true' on it.\n// Otherwise it is readonly by default\nf.$watch(u.taReadonly,function(a,b){b!==a&&(a?(r.addClass(\"ta-readonly\"),\n// we changed to readOnly mode (taReadonly='true')\n\"textarea\"!==r[0].tagName.toLowerCase()&&\"input\"!==r[0].tagName.toLowerCase()||r.attr(\"disabled\",\"disabled\"),void 0!==r.attr(\"contenteditable\")&&r.attr(\"contenteditable\")&&r.removeAttr(\"contenteditable\"),\n// turn ON selector click handlers\nangular.forEach(j,function(a){r.find(a).on(\"click\",$)}),r.off(\"drop\",oa)):(r.removeClass(\"ta-readonly\"),\n// we changed to NOT readOnly mode (taReadonly='false')\n\"textarea\"===r[0].tagName.toLowerCase()||\"input\"===r[0].tagName.toLowerCase()?r.removeAttr(\"disabled\"):D&&r.attr(\"contenteditable\",\"true\"),\n// remove the selector click handlers\nangular.forEach(j,function(a){r.find(a).off(\"click\",$)}),r.on(\"drop\",oa)),F=a)})),\n// Initialise the selectableElements\n// if in WYSIWYG and readOnly we kill the use of links by clicking\nD&&!F&&(angular.forEach(j,function(a){r.find(a).on(\"click\",$)}),r.on(\"drop\",oa))}}}]);\n// this global var is used to prevent multiple fires of the drop event. Needs to be global to the textAngular file.\nvar t=!1,u=angular.module(\"textAngular\",[\"ngSanitize\",\"textAngularSetup\",\"textAngular.factories\",\"textAngular.DOM\",\"textAngular.validators\",\"textAngular.taBind\"]);//This makes ngSanitize required\nreturn u.config([function(){\n// clear taTools variable. Just catches testing and any other time that this config may run multiple times...\nangular.forEach(e,function(a,b){delete e[b]})}]),u.directive(\"textAngular\",[\"$compile\",\"$timeout\",\"taOptions\",\"taSelection\",\"taExecCommand\",\"textAngularManager\",\"$document\",\"$animate\",\"$log\",\"$q\",\"$parse\",function(b,c,d,e,f,g,h,i,j,k,l){return{require:\"?ngModel\",scope:{},restrict:\"EA\",priority:2,// So we override validators correctly\nlink:function(m,n,o,p){\n// all these vars should not be accessable outside this directive\nvar q,r,s,t,u,v,w,x,y,z,A,B,C=o.serial?o.serial:Math.floor(1e16*Math.random());m._name=o.name?o.name:\"textAngularEditor\"+C;var D=function(a,b,d){c(function(){a.one(b,d)},100)};if(y=f(o.taDefaultWrap),\n// get the settings from the defaults and add our specific functions that need to be on the scope\nangular.extend(m,angular.copy(d),{\n// wraps the selection in the provided tag / execCommand function. Should only be called in WYSIWYG mode.\nwrapSelection:function(a,b,c){\n// we restore the saved selection that was saved when focus was lost\n/* NOT FUNCTIONAL YET */\n/* textAngularManager.restoreFocusSelection(scope._name, scope); */\n\"undo\"===a.toLowerCase()?m[\"$undoTaBindtaTextElement\"+C]():\"redo\"===a.toLowerCase()?m[\"$redoTaBindtaTextElement\"+C]():(\n// catch errors like FF erroring when you try to force an undo with nothing done\ny(a,!1,b,m.defaultTagAttributes),c&&\n// re-apply the selectable tool events\nm[\"reApplyOnSelectorHandlerstaTextElement\"+C](),\n// refocus on the shown display element, this fixes a display bug when using :focus styles to outline the box.\n// You still have focus on the text/html input it just doesn't show up\nm.displayElements.text[0].focus())},showHtml:m.$eval(o.taShowHtml)||!1}),\n// setup the options from the optional attributes\no.taFocussedClass&&(m.classes.focussed=o.taFocussedClass),o.taTextEditorClass&&(m.classes.textEditor=o.taTextEditorClass),o.taHtmlEditorClass&&(m.classes.htmlEditor=o.taHtmlEditorClass),o.taDefaultTagAttributes)try{\n//\tTODO: This should use angular.merge to enhance functionality once angular 1.4 is required\nangular.extend(m.defaultTagAttributes,angular.fromJson(o.taDefaultTagAttributes))}catch(a){j.error(a)}\n// optional setup functions\no.taTextEditorSetup&&(m.setup.textEditorSetup=m.$parent.$eval(o.taTextEditorSetup)),o.taHtmlEditorSetup&&(m.setup.htmlEditorSetup=m.$parent.$eval(o.taHtmlEditorSetup)),\n// optional fileDropHandler function\no.taFileDrop?m.fileDropHandler=m.$parent.$eval(o.taFileDrop):m.fileDropHandler=m.defaultFileDropHandler,w=n[0].innerHTML,\n// clear the original content\nn[0].innerHTML=\"\",\n// Setup the HTML elements as variable references for use later\nm.displayElements={\n// we still need the hidden input even with a textarea as the textarea may have invalid/old input in it,\n// wheras the input will ALLWAYS have the correct value.\nforminput:angular.element(\"<input type='hidden' tabindex='-1' style='display: none;'>\"),html:angular.element(\"<textarea></textarea>\"),text:angular.element(\"<div></div>\"),\n// other toolbased elements\nscrollWindow:angular.element(\"<div class='ta-scroll-window'></div>\"),popover:angular.element('<div class=\"popover fade bottom\" style=\"max-width: none; width: 305px;\"></div>'),popoverArrow:angular.element('<div class=\"arrow\"></div>'),popoverContainer:angular.element('<div class=\"popover-content\"></div>'),resize:{overlay:angular.element('<div class=\"ta-resizer-handle-overlay\"></div>'),background:angular.element('<div class=\"ta-resizer-handle-background\"></div>'),anchors:[angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-tl\"></div>'),angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-tr\"></div>'),angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-bl\"></div>'),angular.element('<div class=\"ta-resizer-handle-corner ta-resizer-handle-corner-br\"></div>')],info:angular.element('<div class=\"ta-resizer-handle-info\"></div>')}},\n// Setup the popover\nm.displayElements.popover.append(m.displayElements.popoverArrow),m.displayElements.popover.append(m.displayElements.popoverContainer),m.displayElements.scrollWindow.append(m.displayElements.popover),m.displayElements.popover.on(\"mousedown\",function(a,b){/* istanbul ignore else: this is for catching the jqLite testing*/\n// this prevents focusout from firing on the editor when clicking anything in the popover\nreturn b&&angular.extend(a,b),a.preventDefault(),!1}),/* istanbul ignore next: popover resize and scroll events handled */\nm.handlePopoverEvents=function(){\"block\"===m.displayElements.popover.css(\"display\")&&(B&&c.cancel(B),B=c(function(){\n//console.log('resize', scope.displayElements.popover.css('display'));\nm.reflowPopover(m.resizeElement),m.reflowResizeOverlay(m.resizeElement)},100))},/* istanbul ignore next: browser resize check */\nangular.element(window).on(\"resize\",m.handlePopoverEvents),/* istanbul ignore next: browser scroll check */\nangular.element(window).on(\"scroll\",m.handlePopoverEvents);\n// we want to know if a given node has a scrollbar!\n// credit to lotif on http://stackoverflow.com/questions/4880381/check-whether-html-element-has-scrollbars\nvar E=function(a){var b,c={vertical:!1,horizontal:!1};try{if(b=window.getComputedStyle(a),null===b)return c}catch(a){/* istanbul ignore next: error handler */\nreturn c}var d=b[\"overflow-y\"],e=b[\"overflow-x\"];return{vertical:(\"scroll\"===d||\"auto\"===d)&&/* istanbul ignore next: not tested */\na.scrollHeight>a.clientHeight,horizontal:(\"scroll\"===e||\"auto\"===e)&&/* istanbul ignore next: not tested */\na.scrollWidth>a.clientWidth}};\n// getScrollTop\n//\n// we structure this so that it can climb the parents of the _el and when it finds\n// one with scrollbars, it adds an EventListener, so that no matter how the\n// DOM is structured in the user APP, if there is a scrollbar not as part of the\n// ta-scroll-window, we will still capture the 'scroll' events...\n// and handle the scroll event properly and do the resize, etc.\n//\nm.getScrollTop=function(a,b){var c=a.scrollTop;/* istanbul ignore next: triggered only if has scrollbar and scrolled */\n/* istanbul ignore next: triggered only if has scrollbar */\n// remove element eventListener\n/* istanbul ignore next: triggered only if has scrollbar and scrolled */\n/* istanbul ignore else: catches only if no scroll */\nreturn\"undefined\"==typeof c&&(c=0),b&&E(a).vertical&&(a.removeEventListener(\"scroll\",m._scrollListener,!1),a.addEventListener(\"scroll\",m._scrollListener,!1)),0!==c?{node:a.nodeName,top:c}:a.parentNode?m.getScrollTop(a.parentNode,b):{node:\"<none>\",top:0}},\n// define the popover show and hide functions\nm.showPopover=function(a){m.getScrollTop(m.displayElements.scrollWindow[0],!0),m.displayElements.popover.css(\"display\",\"block\"),\n// we must use a $timeout here, or the css change to the\n// displayElements.resize.overlay will not take!!!\n// WHY???\nc(function(){m.displayElements.resize.overlay.css(\"display\",\"block\")}),m.resizeElement=a,m.reflowPopover(a),i.addClass(m.displayElements.popover,\"in\"),D(h.find(\"body\"),\"click keyup\",function(){m.hidePopover()})},/* istanbul ignore next: browser scroll event handler */\nm._scrollListener=function(a,b){m.handlePopoverEvents()},m.reflowPopover=function(a){var b=m.getScrollTop(m.displayElements.scrollWindow[0],!1),c=a[0].offsetTop-b.top;\n//var spaceBelowImage = scope.displayElements.text[0].offsetHeight - _el[0].offsetHeight - spaceAboveImage;\n//console.log(spaceAboveImage, spaceBelowImage);\n/* istanbul ignore if: catches only if near bottom of editor */\nc<51?(m.displayElements.popover.css(\"top\",a[0].offsetTop+a[0].offsetHeight+m.displayElements.scrollWindow[0].scrollTop+\"px\"),m.displayElements.popover.removeClass(\"top\").addClass(\"bottom\")):(m.displayElements.popover.css(\"top\",a[0].offsetTop-54+m.displayElements.scrollWindow[0].scrollTop+\"px\"),m.displayElements.popover.removeClass(\"bottom\").addClass(\"top\"));var d=m.displayElements.text[0].offsetWidth-m.displayElements.popover[0].offsetWidth,e=a[0].offsetLeft+a[0].offsetWidth/2-m.displayElements.popover[0].offsetWidth/2,f=Math.max(0,Math.min(d,e)),g=Math.min(e,Math.max(0,e-d))-11;f+=window.scrollX,g-=window.scrollX,m.displayElements.popover.css(\"left\",f+\"px\"),m.displayElements.popoverArrow.css(\"margin-left\",g+\"px\")},m.hidePopover=function(){m.displayElements.popover.css(\"display\",\"none\"),m.displayElements.popoverContainer.attr(\"style\",\"\"),m.displayElements.popoverContainer.attr(\"class\",\"popover-content\"),m.displayElements.popover.removeClass(\"in\"),m.displayElements.resize.overlay.css(\"display\",\"none\")},\n// setup the resize overlay\nm.displayElements.resize.overlay.append(m.displayElements.resize.background),angular.forEach(m.displayElements.resize.anchors,function(a){m.displayElements.resize.overlay.append(a)}),m.displayElements.resize.overlay.append(m.displayElements.resize.info),m.displayElements.scrollWindow.append(m.displayElements.resize.overlay),\n// A click event on the resize.background will now shift the focus to the editor\n/* istanbul ignore next: click on the resize.background to focus back to editor */\nm.displayElements.resize.background.on(\"click\",function(a){m.displayElements.text[0].focus()}),\n// define the show and hide events\nm.reflowResizeOverlay=function(a){a=angular.element(a)[0],m.displayElements.resize.overlay.css({display:\"block\",left:a.offsetLeft-5+\"px\",top:a.offsetTop-5+\"px\",width:a.offsetWidth+10+\"px\",height:a.offsetHeight+10+\"px\"}),m.displayElements.resize.info.text(a.offsetWidth+\" x \"+a.offsetHeight)},/* istanbul ignore next: pretty sure phantomjs won't test this */\nm.showResizeOverlay=function(a){var b=h.find(\"body\");z=function(c){var d={width:parseInt(a.attr(\"width\")),height:parseInt(a.attr(\"height\")),x:c.clientX,y:c.clientY};(void 0===d.width||isNaN(d.width))&&(d.width=a[0].offsetWidth),(void 0===d.height||isNaN(d.height))&&(d.height=a[0].offsetHeight),m.hidePopover();var e=d.height/d.width,f=function(b){function c(a){return Math.round(Math.max(0,a))}\n// calculate new size\nvar f={x:Math.max(0,d.width+(b.clientX-d.x)),y:Math.max(0,d.height+(b.clientY-d.y))},g=void 0!==o.taResizeForceAspectRatio,h=o.taResizeMaintainAspectRatio,i=g||h&&!b.shiftKey;if(i){var j=f.y/f.x;f.x=e>j?f.x:f.y/e,f.y=e>j?f.x*e:f.y}var k=angular.element(a);k.css(\"height\",c(f.y)+\"px\"),k.css(\"width\",c(f.x)+\"px\"),\n// reflow the popover tooltip\nm.reflowResizeOverlay(a)};b.on(\"mousemove\",f),D(b,\"mouseup\",function(a){a.preventDefault(),a.stopPropagation(),b.off(\"mousemove\",f),\n// at this point, we need to force the model to update! since the css has changed!\n// this fixes bug: #862 - we now hide the popover -- as this seems more consitent.\n// there are still issues under firefox, the window does not repaint. -- not sure\n// how best to resolve this, but clicking anywhere works.\nm.$apply(function(){m.hidePopover(),m.updateTaBindtaTextElement()},100)}),c.stopPropagation(),c.preventDefault()},m.displayElements.resize.anchors[3].off(\"mousedown\"),m.displayElements.resize.anchors[3].on(\"mousedown\",z),m.reflowResizeOverlay(a),D(b,\"click\",function(){m.hideResizeOverlay()})},/* istanbul ignore next: pretty sure phantomjs won't test this */\nm.hideResizeOverlay=function(){m.displayElements.resize.anchors[3].off(\"mousedown\",z),m.displayElements.resize.overlay.css(\"display\",\"none\")},\n// allow for insertion of custom directives on the textarea and div\nm.setup.htmlEditorSetup(m.displayElements.html),m.setup.textEditorSetup(m.displayElements.text),m.displayElements.html.attr({id:\"taHtmlElement\"+C,\"ng-show\":\"showHtml\",\"ta-bind\":\"ta-bind\",\"ng-model\":\"html\",\"ng-model-options\":n.attr(\"ng-model-options\")}),m.displayElements.text.attr({id:\"taTextElement\"+C,contentEditable:\"true\",\"ta-bind\":\"ta-bind\",\"ng-model\":\"html\",\"ng-model-options\":n.attr(\"ng-model-options\")}),m.displayElements.scrollWindow.attr({\"ng-hide\":\"showHtml\"}),o.taDefaultWrap&&\n// taDefaultWrap is only applied to the text and not the html view\nm.displayElements.text.attr(\"ta-default-wrap\",o.taDefaultWrap),o.taUnsafeSanitizer&&(m.displayElements.text.attr(\"ta-unsafe-sanitizer\",o.taUnsafeSanitizer),m.displayElements.html.attr(\"ta-unsafe-sanitizer\",o.taUnsafeSanitizer)),o.taKeepStyles&&(m.displayElements.text.attr(\"ta-keep-styles\",o.taKeepStyles),m.displayElements.html.attr(\"ta-keep-styles\",o.taKeepStyles)),\n// add the main elements to the origional element\nm.displayElements.scrollWindow.append(m.displayElements.text),n.append(m.displayElements.scrollWindow),n.append(m.displayElements.html),m.displayElements.forminput.attr(\"name\",m._name),n.append(m.displayElements.forminput),o.tabindex&&(n.removeAttr(\"tabindex\"),m.displayElements.text.attr(\"tabindex\",o.tabindex),m.displayElements.html.attr(\"tabindex\",o.tabindex)),o.placeholder&&(m.displayElements.text.attr(\"placeholder\",o.placeholder),m.displayElements.html.attr(\"placeholder\",o.placeholder)),o.taDisabled&&(m.displayElements.text.attr(\"ta-readonly\",\"disabled\"),m.displayElements.html.attr(\"ta-readonly\",\"disabled\"),m.disabled=m.$parent.$eval(o.taDisabled),m.$parent.$watch(o.taDisabled,function(a){m.disabled=a,m.disabled?n.addClass(m.classes.disabled):n.removeClass(m.classes.disabled)})),o.taPaste&&(m._pasteHandler=function(a){return l(o.taPaste)(m.$parent,{$html:a})},m.displayElements.text.attr(\"ta-paste\",\"_pasteHandler($html)\")),\n// compile the scope with the text and html elements only - if we do this with the main element it causes a compile loop\nb(m.displayElements.scrollWindow)(m),b(m.displayElements.html)(m),m.updateTaBindtaTextElement=m[\"updateTaBindtaTextElement\"+C],m.updateTaBindtaHtmlElement=m[\"updateTaBindtaHtmlElement\"+C],\n// add the classes manually last\nn.addClass(\"ta-root\"),m.displayElements.scrollWindow.addClass(\"ta-text ta-editor \"+m.classes.textEditor),m.displayElements.html.addClass(\"ta-html ta-editor \"+m.classes.htmlEditor);var F=function(a,b){/* istanbul ignore next: this is only here because of a bug in rangy where rangy.saveSelection() has cleared the state */\nb!==h[0].queryCommandState(a)&&h[0].execCommand(a,!1,null)};\n// used in the toolbar actions\nm._actionRunning=!1;var G=!1;\n// changes to the model variable from outside the html/text inputs\n// if no ngModel, then the only input is from inside text-angular\nif(m.startAction=function(){var b=!1,c=!1,d=!1,e=!1;\n//console.log('B', $document[0].queryCommandState('bold'), 'I', $document[0].queryCommandState('italic'), '_', $document[0].queryCommandState('underline'), 'S', $document[0].queryCommandState('strikeThrough') );\n//console.log('B', _beforeStateBold, 'I', _beforeStateItalic, '_', _beforeStateUnderline, 'S', _beforeStateStrikethough);\n// if rangy library is loaded return a function to reload the current selection\n// rangy.saveSelection() clear the state of bold, italic, underline, strikethrough\n// so we reset them here....!!!\n// this fixes bugs #423, #1129, #1105, #693 which are actually rangy bugs!\nreturn m._actionRunning=!0,b=h[0].queryCommandState(\"bold\"),c=h[0].queryCommandState(\"italic\"),d=h[0].queryCommandState(\"underline\"),e=h[0].queryCommandState(\"strikeThrough\"),G=a.saveSelection(),F(\"bold\",b),F(\"italic\",c),F(\"underline\",d),F(\"strikeThrough\",e),function(){G&&a.restoreSelection(G)}},m.endAction=function(){m._actionRunning=!1,G&&(m.showHtml?m.displayElements.html[0].focus():m.displayElements.text[0].focus(),\n// rangy.restoreSelection(_savedSelection);\na.removeMarkers(G)),G=!1,m.updateSelectedStyles(),\n// only update if in text or WYSIWYG mode\nm.showHtml||m[\"updateTaBindtaTextElement\"+C]()},\n// note that focusout > focusin is called everytime we click a button - except bad support: http://www.quirksmode.org/dom/events/blurfocus.html\n// cascades to displayElements.text and displayElements.html automatically.\nu=function(a){m.focussed=!0,n.addClass(m.classes.focussed),/*******  NOT FUNCTIONAL YET\n                    if (e.target.id === 'taTextElement' + _serial) {\n                        console.log('_focusin taTextElement');\n                        // we only do this if NOT focussed\n                        textAngularManager.restoreFocusSelection(scope._name);\n                    }\n*******/\nx.focus(),n.triggerHandler(\"focus\"),\n// we call editorScope.updateSelectedStyles() here because we want the toolbar to be focussed\n// as soon as we have focus.  Otherwise this only happens on mousedown or keydown etc...\n/* istanbul ignore else: don't run if already running */\nm.updateSelectedStyles&&!m._bUpdateSelectedStyles&&\n// we don't set editorScope._bUpdateSelectedStyles here, because we do not want the\n// updateSelectedStyles() to run twice which it will do after 200 msec if we have\n// set editorScope._bUpdateSelectedStyles\n//\n// WOW, normally I would do a scope.$apply here, but this causes ERRORs when doing tests!\nc(function(){m.updateSelectedStyles()},0)},m.displayElements.html.on(\"focus\",u),m.displayElements.text.on(\"focus\",u),v=function(a){/****************** NOT FUNCTIONAL YET\n                    try {\n                        var _s = rangy.getSelection();\n                        if (_s) {\n                            // we save the selection when we loose focus so that if do a wrapSelection, the\n                            // apropriate selection in the editor is restored before action.\n                            var _savedFocusRange = rangy.saveRange(_s.getRangeAt(0));\n                            textAngularManager.saveFocusSelection(scope._name, _savedFocusRange);\n                        }\n                    } catch(error) { }\n                    *****************/\n// if we are NOT runnig an action and have NOT focussed again on the text etc then fire the blur events\n// to prevent multiple apply error defer to next seems to work.\nreturn m._actionRunning||h[0].activeElement===m.displayElements.html[0]||h[0].activeElement===m.displayElements.text[0]||(n.removeClass(m.classes.focussed),x.unfocus(),c(function(){m._bUpdateSelectedStyles=!1,n.triggerHandler(\"blur\"),m.focussed=!1},0)),a.preventDefault(),!1},m.displayElements.html.on(\"blur\",v),m.displayElements.text.on(\"blur\",v),m.displayElements.text.on(\"paste\",function(a){n.triggerHandler(\"paste\",a)}),\n// Setup the default toolbar tools, this way allows the user to add new tools like plugins.\n// This is on the editor for future proofing if we find a better way to do this.\nm.queryFormatBlockState=function(a){\n// $document[0].queryCommandValue('formatBlock') errors in Firefox if we call this when focussed on the textarea\nreturn!m.showHtml&&a.toLowerCase()===h[0].queryCommandValue(\"formatBlock\").toLowerCase()},m.queryCommandState=function(a){\n// $document[0].queryCommandValue('formatBlock') errors in Firefox if we call this when focussed on the textarea\nreturn m.showHtml?\"\":h[0].queryCommandState(a)},m.switchView=function(){m.showHtml=!m.showHtml,i.enabled(!1,m.displayElements.html),i.enabled(!1,m.displayElements.text),\n//Show the HTML view\n/* istanbul ignore next: ngModel exists check */\n/* THIS is not the correct thing to do, here....\n   The ngModel is correct, but it is not formatted as the user as done it...\n                    var _model;\n                    if (ngModel) {\n                        _model = ngModel.$viewValue;\n                    } else {\n                        _model = scope.html;\n                    }\n                    var _html = scope.displayElements.html[0].value;\n                    if (getDomFromHtml(_html).childElementCount !== getDomFromHtml(_model).childElementCount) {\n                        // the model and the html do not agree\n                        // they can get out of sync and when they do, we correct that here...\n                        scope.displayElements.html.val(_model);\n                    }\n*/\nm.showHtml?\n//defer until the element is visible\nc(function(){\n// [0] dereferences the DOM object from the angular.element\nreturn i.enabled(!0,m.displayElements.html),i.enabled(!0,m.displayElements.text),m.displayElements.html[0].focus()},100):\n//Show the WYSIWYG view\n//defer until the element is visible\nc(function(){\n// [0] dereferences the DOM object from the angular.element\nreturn i.enabled(!0,m.displayElements.html),i.enabled(!0,m.displayElements.text),m.displayElements.text[0].focus()},100)},o.ngModel){var H=!0;p.$render=function(){if(H){\n// we need this firstRun to set the originalContents otherwise it gets overrided by the setting of ngModel to undefined from NaN\nH=!1;\n// if view value is null or undefined initially and there was original content, set to the original content\nvar a=m.$parent.$eval(o.ngModel);void 0!==a&&null!==a||!w||\"\"===w||\n// on passing through to taBind it will be sanitised\np.$setViewValue(w)}m.displayElements.forminput.val(p.$viewValue),\n// if the editors aren't focused they need to be updated, otherwise they are doing the updating\nm.html=p.$viewValue||\"\"},\n// trigger the validation calls\nn.attr(\"required\")&&(p.$validators.required=function(a,b){var c=a||b;return!(!c||\"\"===c.trim())})}else\n// if no ngModel then update from the contents of the origional html.\nm.displayElements.forminput.val(w),m.html=w;if(\n// changes from taBind back up to here\nm.$watch(\"html\",function(a,b){a!==b&&(o.ngModel&&p.$viewValue!==a&&p.$setViewValue(a),m.displayElements.forminput.val(a))}),o.taTargetToolbars)x=g.registerEditor(m._name,m,o.taTargetToolbars.split(\",\"));else{var I=angular.element('<div text-angular-toolbar name=\"textAngularToolbar'+C+'\">');\n// passthrough init of toolbar options\no.taToolbar&&I.attr(\"ta-toolbar\",o.taToolbar),o.taToolbarClass&&I.attr(\"ta-toolbar-class\",o.taToolbarClass),o.taToolbarGroupClass&&I.attr(\"ta-toolbar-group-class\",o.taToolbarGroupClass),o.taToolbarButtonClass&&I.attr(\"ta-toolbar-button-class\",o.taToolbarButtonClass),o.taToolbarActiveButtonClass&&I.attr(\"ta-toolbar-active-button-class\",o.taToolbarActiveButtonClass),o.taFocussedClass&&I.attr(\"ta-focussed-class\",o.taFocussedClass),n.prepend(I),b(I)(m.$parent),x=g.registerEditor(m._name,m,[\"textAngularToolbar\"+C])}m.$on(\"$destroy\",function(){g.unregisterEditor(m._name),angular.element(window).off(\"blur\"),angular.element(window).off(\"resize\",m.handlePopoverEvents),angular.element(window).off(\"scroll\",m.handlePopoverEvents)}),\n// catch element select event and pass to toolbar tools\nm.$on(\"ta-element-select\",function(a,b){x.triggerElementSelect(a,b)&&m[\"reApplyOnSelectorHandlerstaTextElement\"+C]()}),/******************* no working fully\n                var distanceFromPoint = function (px, py, x, y) {\n                    return Math.sqrt((px-x)*(px-x)+(py-y)*(py-y));\n                };\n                // because each object is a rectangle and we have a single point,\n                // we need to give priority if the point is inside the rectangle\n                var getPositionDistance = function(el, x, y) {\n                    var range = document.createRange();\n                    range.selectNode(el);\n                    var rect = range.getBoundingClientRect();\n                    console.log(el, rect);\n                    range.detach();\n                    var bcr = rect;\n                    // top left\n                    var d1 = distanceFromPoint(bcr.left, bcr.top, x, y);\n                    // bottom left\n                    var d2 = distanceFromPoint(bcr.left, bcr.bottom, x, y);\n                    // top right\n                    var d3 = distanceFromPoint(bcr.right, bcr.top, x, y);\n                    // bottom right\n                    var d4 = distanceFromPoint(bcr.right, bcr.bottom, x, y);\n                    return Math.min(d1, d2, d3, d4);\n                };\n                var findClosest = function(el, minElement, maxDistance, x, y) {\n                    var _d=0;\n                    for (var i = 0; i < el.childNodes.length; i++) {\n                        var _n = el.childNodes[i];\n                        if (!_n.childNodes.length) {\n                            _d = getPositionDistance(_n, x, y);\n                            //console.log(_n, _n.childNodes, _d);\n                            if (_d < maxDistance) {\n                                maxDistance = _d;\n                                minElement = _n;\n                            }\n                        }\n                        var res = findClosest(_n, minElement, maxDistance, x, y);\n                        if (res.max < maxDistance) {\n                            maxDistance = res.max;\n                            minElement = res.min;\n                        }\n                    }\n                    return { max: maxDistance, min: minElement };\n                };\n                var getClosestElement = function (el, x, y) {\n                    return findClosest(el, null, 12341234124, x, y);\n                };\n****************/\nm.$on(\"ta-drop-event\",function(a,b,d,f){f&&f.files&&f.files.length>0?(m.displayElements.text[0].focus(),\n// we must set the location of the drop!\n//console.log(dropEvent.clientX, dropEvent.clientY, dropEvent.target);\ne.setSelectionToElementEnd(d.target),angular.forEach(f.files,function(a){\n// taking advantage of boolean execution, if the fileDropHandler returns true, nothing else after it is executed\n// If it is false then execute the defaultFileDropHandler if the fileDropHandler is NOT the default one\n// Once one of these has been executed wrap the result as a promise, if undefined or variable update the taBind, else we should wait for the promise\ntry{k.when(m.fileDropHandler(a,m.wrapSelection)||m.fileDropHandler!==m.defaultFileDropHandler&&k.when(m.defaultFileDropHandler(a,m.wrapSelection))).then(function(){m[\"updateTaBindtaTextElement\"+C]()})}catch(a){j.error(a)}}),d.preventDefault(),d.stopPropagation()):c(function(){m[\"updateTaBindtaTextElement\"+C]()},0)}),\n// the following is for applying the active states to the tools that support it\nm._bUpdateSelectedStyles=!1,/* istanbul ignore next: browser window/tab leave check */\nangular.element(window).on(\"blur\",function(){m._bUpdateSelectedStyles=!1,m.focussed=!1}),\n// loop through all the tools polling their activeState function if it exists\nm.updateSelectedStyles=function(){var a;/* istanbul ignore next: This check is to ensure multiple timeouts don't exist */\nA&&c.cancel(A),\n// test if the common element ISN'T the root ta-text node\nvoid 0!==(a=e.getSelectionElement())&&a.parentNode!==m.displayElements.text[0]?x.updateSelectedStyles(angular.element(a)):x.updateSelectedStyles(),\n// used to update the active state when a key is held down, ie the left arrow\n/* istanbul ignore else: browser only check */\nm._bUpdateSelectedStyles&&(A=c(m.updateSelectedStyles,200))},\n// start updating on keydown\nq=function(){/* istanbul ignore next: ie catch */\n/* istanbul ignore next: ie catch */\n/* istanbul ignore else: don't run if already running */\nreturn m.focussed?void(m._bUpdateSelectedStyles||(m._bUpdateSelectedStyles=!0,m.$apply(function(){m.updateSelectedStyles()}))):void(m._bUpdateSelectedStyles=!1)},m.displayElements.html.on(\"keydown\",q),m.displayElements.text.on(\"keydown\",q),\n// stop updating on key up and update the display/model\nr=function(){m._bUpdateSelectedStyles=!1},m.displayElements.html.on(\"keyup\",r),m.displayElements.text.on(\"keyup\",r),\n// stop updating on key up and update the display/model\ns=function(a,b){\n// bug fix for Firefox.  If we are selecting a <a> already, any characters will\n// be added within the <a> which is bad!\n/* istanbul ignore next: don't see how to test this... */\nif(e.getSelection){var c=e.getSelection();\n// in a weird case (can't reproduce) taSelection.getSelectionElement() can be undefined!!\n// this comes from range.commonAncestorContainer;\n// so I check for this here which fixes the error case\ne.getSelectionElement()&&\"a\"===e.getSelectionElement().nodeName.toLowerCase()&&(\n// check and see if we are at the edge of the <a>\n3===c.start.element.nodeType&&c.start.element.textContent.length===c.end.offset&&\n// we are at the end of the <a>!!!\n// so move the selection to after the <a>!!\ne.setSelectionAfterElement(e.getSelectionElement()),3===c.start.element.nodeType&&0===c.start.offset&&\n// we are at the start of the <a>!!!\n// so move the selection before the <a>!!\ne.setSelectionBeforeElement(e.getSelectionElement()))}/* istanbul ignore else: this is for catching the jqLite testing*/\nb&&angular.extend(a,b),m.$apply(function(){if(x.sendKeyCommand(a))/* istanbul ignore else: don't run if already running */\nreturn m._bUpdateSelectedStyles||m.updateSelectedStyles(),a.preventDefault(),!1})},m.displayElements.html.on(\"keypress\",s),m.displayElements.text.on(\"keypress\",s),\n// update the toolbar active states when we click somewhere in the text/html boxed\nt=function(){\n// ensure only one execution of updateSelectedStyles()\nm._bUpdateSelectedStyles=!1,\n// for some reason, unless we do a $timeout here, after a _mouseup when the line is\n// highlighted, and instead use a scope.$apply(function(){ scope.updateSelectedStyles(); });\n// doesn't work properly, so we replaced this with:\n/* istanbul ignore next: not tested  */\nc(function(){m.updateSelectedStyles()},0)},m.displayElements.html.on(\"mouseup\",t),m.displayElements.text.on(\"mouseup\",t)}}}]),u.service(\"textAngularManager\",[\"taToolExecuteAction\",\"taTools\",\"taRegisterTool\",\"$interval\",\"$rootScope\",\"$log\",function(a,b,c,d,e,g){\n// this service is used to manage all textAngular editors and toolbars.\n// All publicly published functions that modify/need to access the toolbar or editor scopes should be in here\n// these contain references to all the editors and toolbars that have been initialised in this app\nvar h,i={},j={},k=0,l=function(a){angular.forEach(j,function(b){b.editorFunctions.updateSelectedStyles(a)})},m=50,n=function(){k=Date.now(),/* istanbul ignore next: setup a one time updateStyles() */\nh=d(function(){l(),h=void 0},m,1)};/* istanbul ignore next: make sure clean up on destroy */\ne.$on(\"destroy\",function(){h&&(d.cancel(h),h=void 0)});var o=function(){Math.abs(Date.now()-k)>m&&\n// we have already triggered the updateStyles a long time back... so setup it again...\nn()};\n// when we focus into a toolbar, we need to set the TOOLBAR's $parent to be the toolbars it's linked to.\n// We also need to set the tools to be updated to be the toolbars...\nreturn{\n// register an editor and the toolbars that it is affected by\nregisterEditor:function(c,d,e){\n// NOTE: name === editorScope._name\n// targetToolbars is an [] of 'toolbar name's\n// targetToolbars are optional, we don't require a toolbar to function\nif(!c||\"\"===c)throw\"textAngular Error: An editor requires a name\";if(!d)throw\"textAngular Error: An editor requires a scope\";if(j[c])throw'textAngular Error: An Editor with name \"'+c+'\" already exists';return j[c]={scope:d,toolbars:e,\n// toolbarScopes used by this editor\ntoolbarScopes:[],_registerToolbarScope:function(a){\n// add to the list late\nthis.toolbars.indexOf(a.name)>=0&&\n// if this toolbarScope is being used by this editor we add it as one of the scopes\nthis.toolbarScopes.push(a)},\n// this is a suite of functions the editor should use to update all it's linked toolbars\neditorFunctions:{disable:function(){\n// disable all linked toolbars\nangular.forEach(j[c].toolbarScopes,function(a){a.disabled=!0})},enable:function(){\n// enable all linked toolbars\nangular.forEach(j[c].toolbarScopes,function(a){a.disabled=!1})},focus:function(){\n// this should be called when the editor is focussed\nangular.forEach(j[c].toolbarScopes,function(a){a._parent=d,a.disabled=!1,a.focussed=!0}),d.focussed=!0},unfocus:function(){\n// this should be called when the editor becomes unfocussed\nangular.forEach(j[c].toolbarScopes,function(a){a.disabled=!0,a.focussed=!1}),d.focussed=!1},updateSelectedStyles:function(a){\n// update the active state of all buttons on liked toolbars\nangular.forEach(j[c].toolbarScopes,function(b){angular.forEach(b.tools,function(c){c.activeState&&(b._parent=d,\n// selectedElement may be undefined if nothing selected\nc.active=c.activeState(a))})})},sendKeyCommand:function(e){\n// we return true if we applied an action, false otherwise\nvar f=!1;return(e.ctrlKey||e.metaKey||e.specialKey)&&angular.forEach(b,function(b,g){if(b.commandKeyCode&&(b.commandKeyCode===e.which||b.commandKeyCode===e.specialKey))for(var h=0;h<j[c].toolbarScopes.length;h++)if(void 0!==j[c].toolbarScopes[h].tools[g]){a.call(j[c].toolbarScopes[h].tools[g],d),f=!0;break}}),f},triggerElementSelect:function(a,e){\n// search through the taTools to see if a match for the tag is made.\n// if there is, see if the tool is on a registered toolbar and not disabled.\n// NOTE: This can trigger on MULTIPLE tools simultaneously.\nvar f=function(a,b){for(var c=!0,d=0;d<b.length;d++)c=c&&a.attr(b[d]);return c},g=[],h={},i=!1;e=angular.element(e);\n// get all valid tools by element name, keep track if one matches the\nvar k=!1;\n// Run the actions on the first visible filtered tool only\nif(angular.forEach(b,function(a,b){a.onElementSelect&&a.onElementSelect.element&&a.onElementSelect.element.toLowerCase()===e[0].tagName.toLowerCase()&&(!a.onElementSelect.filter||a.onElementSelect.filter(e))&&(\n// this should only end up true if the element matches the only attributes\nk=k||angular.isArray(a.onElementSelect.onlyWithAttrs)&&f(e,a.onElementSelect.onlyWithAttrs),a.onElementSelect.onlyWithAttrs&&!f(e,a.onElementSelect.onlyWithAttrs)||(h[b]=a))}),\n// if we matched attributes to filter on, then filter, else continue\nk?(angular.forEach(h,function(a,b){a.onElementSelect.onlyWithAttrs&&f(e,a.onElementSelect.onlyWithAttrs)&&g.push({name:b,tool:a})}),\n// sort most specific (most attrs to find) first\ng.sort(function(a,b){return b.tool.onElementSelect.onlyWithAttrs.length-a.tool.onElementSelect.onlyWithAttrs.length})):angular.forEach(h,function(a,b){g.push({name:b,tool:a})}),g.length>0)for(var l=0;l<g.length;l++){for(var m=g[l].tool,n=g[l].name,o=0;o<j[c].toolbarScopes.length;o++)if(void 0!==j[c].toolbarScopes[o].tools[n]){m.onElementSelect.action.call(j[c].toolbarScopes[o].tools[n],a,e,d),i=!0;break}if(i)break}return i}}},angular.forEach(e,function(a){i[a]&&j[c].toolbarScopes.push(i[a])}),o(),j[c].editorFunctions},\n// retrieve editor by name, largely used by testing suites only\nretrieveEditor:function(a){return j[a]},unregisterEditor:function(a){delete j[a],o()},\n// registers a toolbar such that it can be linked to editors\nregisterToolbar:function(a){if(!a)throw\"textAngular Error: A toolbar requires a scope\";if(!a.name||\"\"===a.name)throw\"textAngular Error: A toolbar requires a name\";if(i[a.name])throw'textAngular Error: A toolbar with name \"'+a.name+'\" already exists';i[a.name]=a,\n// walk all the editors and connect this toolbarScope to the editors.... if we need to.  This way, it does\n// not matter if we register the editors after the toolbars or not\n// Note the editor will ignore this toolbarScope if it is not connected to it...\nangular.forEach(j,function(b){b._registerToolbarScope(a)}),o()},\n// retrieve toolbar by name, largely used by testing suites only\nretrieveToolbar:function(a){return i[a]},\n// retrieve toolbars by editor name, largely used by testing suites only\nretrieveToolbarsViaEditor:function(a){var b=[],c=this;return angular.forEach(this.retrieveEditor(a).toolbars,function(a){b.push(c.retrieveToolbar(a))}),b},unregisterToolbar:function(a){delete i[a],o()},\n// functions for updating the toolbar buttons display\nupdateToolsDisplay:function(a){\n// pass a partial struct of the taTools, this allows us to update the tools on the fly, will not change the defaults.\nvar b=this;angular.forEach(a,function(a,c){b.updateToolDisplay(c,a)})},\n// this function resets all toolbars to their default tool definitions\nresetToolsDisplay:function(){var a=this;angular.forEach(b,function(b,c){a.resetToolDisplay(c)}),o()},\n// update a tool on all toolbars\nupdateToolDisplay:function(a,b){var c=this;angular.forEach(i,function(d,e){c.updateToolbarToolDisplay(e,a,b)}),o()},\n// resets a tool to the default/starting state on all toolbars\nresetToolDisplay:function(a){var b=this;angular.forEach(i,function(c,d){b.resetToolbarToolDisplay(d,a)}),o()},\n// update a tool on a specific toolbar\nupdateToolbarToolDisplay:function(a,b,c){if(!i[a])throw'textAngular Error: No Toolbar with name \"'+a+'\" exists';i[a].updateToolDisplay(b,c)},\n// reset a tool on a specific toolbar to it's default starting value\nresetToolbarToolDisplay:function(a,c){if(!i[a])throw'textAngular Error: No Toolbar with name \"'+a+'\" exists';i[a].updateToolDisplay(c,b[c],!0)},\n// removes a tool from all toolbars and it's definition\nremoveTool:function(a){delete b[a],angular.forEach(i,function(b){delete b.tools[a];for(var c=0;c<b.toolbar.length;c++){for(var d,e=0;e<b.toolbar[c].length;e++){if(b.toolbar[c][e]===a){d={group:c,index:e};break}if(void 0!==d)break}void 0!==d&&(b.toolbar[d.group].slice(d.index,1),b._$element.children().eq(d.group).children().eq(d.index).remove())}}),o()},\n// toolkey, toolDefinition are required. If group is not specified will pick the last group, if index isnt defined will append to group\naddTool:function(a,b,d,e){c(a,b),angular.forEach(i,function(c){c.addTool(a,b,d,e)}),o()},\n// adds a Tool but only to one toolbar not all\naddToolToToolbar:function(a,b,d,e,f){c(a,b),i[d].addTool(a,b,e,f),o()},\n// this is used when externally the html of an editor has been changed and textAngular needs to be notified to update the model.\n// this will call a $digest if not already happening\nrefreshEditor:function(a){if(!j[a])throw'textAngular Error: No Editor with name \"'+a+'\" exists';j[a].scope.updateTaBindtaTextElement(),/* istanbul ignore else: phase catch */\nj[a].scope.$$phase||j[a].scope.$digest(),o()},\n// this is used by taBind to send a key command in response to a special key event\nsendKeyCommand:function(a,b){var c=j[a._name];/* istanbul ignore else: if nothing to do, do nothing */\nif(c&&c.editorFunctions.sendKeyCommand(b))/* istanbul ignore else: don't run if already running */\nreturn a._bUpdateSelectedStyles||a.updateSelectedStyles(),b.preventDefault(),!1},\n//\n// When a toolbar and tools are created, it isn't until there is a key event or mouse event\n// that the updateSelectedStyles() is called behind the scenes.\n// This function forces an update through the existing editors to help the application make sure\n// the inital state is correct.\n//\nupdateStyles:l,\n// return the current version of textAngular in use to the user\ngetVersion:function(){return f},\n// for testing\ngetToolbarScopes:function(){var a=[];return angular.forEach(j,function(b){a=a.concat(b.toolbarScopes)}),a}}}]),u.directive(\"textAngularToolbar\",[\"$compile\",\"textAngularManager\",\"taOptions\",\"taTools\",\"taToolExecuteAction\",\"$window\",function(a,b,c,d,e,f){return{scope:{name:\"@\"},restrict:\"EA\",link:function(g,h,i){if(!g.name||\"\"===g.name)throw\"textAngular Error: A toolbar requires a name\";angular.extend(g,angular.copy(c)),i.taToolbar&&(g.toolbar=g.$parent.$eval(i.taToolbar)),i.taToolbarClass&&(g.classes.toolbar=i.taToolbarClass),i.taToolbarGroupClass&&(g.classes.toolbarGroup=i.taToolbarGroupClass),i.taToolbarButtonClass&&(g.classes.toolbarButton=i.taToolbarButtonClass),i.taToolbarActiveButtonClass&&(g.classes.toolbarButtonActive=i.taToolbarActiveButtonClass),i.taFocussedClass&&(g.classes.focussed=i.taFocussedClass),g.disabled=!0,g.focussed=!1,g._$element=h,h[0].innerHTML=\"\",h.addClass(\"ta-toolbar \"+g.classes.toolbar),g.$watch(\"focussed\",function(){g.focussed?h.addClass(g.classes.focussed):h.removeClass(g.classes.focussed)});var j=function(b,c){var d;if(d=b&&b.display?angular.element(b.display):angular.element(\"<button type='button'>\"),b&&b.class?d.addClass(b.class):d.addClass(g.classes.toolbarButton),d.attr(\"name\",c.name),\n// important to not take focus from the main text/html entry\nd.attr(\"ta-button\",\"ta-button\"),d.attr(\"ng-disabled\",\"isDisabled()\"),d.attr(\"tabindex\",\"-1\"),d.attr(\"ng-click\",\"executeAction()\"),d.attr(\"ng-class\",\"displayActiveToolClass(active)\"),b&&b.tooltiptext&&d.attr(\"title\",b.tooltiptext),b&&!b.display&&!c._display&&(\n// first clear out the current contents if any\nd[0].innerHTML=\"\",\n// add the buttonText\nb.buttontext&&(d[0].innerHTML=b.buttontext),b.iconclass)){var e=angular.element(\"<i>\"),f=d[0].innerHTML;e.addClass(b.iconclass),d[0].innerHTML=\"\",d.append(e),f&&\"\"!==f&&d.append(\"&nbsp;\"+f)}return c._lastToolDefinition=angular.copy(b),a(d)(c)};\n// Keep a reference for updating the active states later\ng.tools={},\n// create the tools in the toolbar\n// default functions and values to prevent errors in testing and on init\ng._parent={disabled:!0,showHtml:!1,queryFormatBlockState:function(){return!1},queryCommandState:function(){return!1}};var k={$window:f,$editor:function(){\n// dynamically gets the editor as it is set\nreturn g._parent},isDisabled:function(){\n// view selection button is always enabled since it doesn not depend on a selction!\n// view selection button is always enabled since it doesn not depend on a selction!\n// this bracket is important as without it it just returns the first bracket and ignores the rest\n// when the button's disabled function/value evaluates to true\n// all buttons except the HTML Switch button should be disabled in the showHtml (RAW html) mode\n// if the toolbar is disabled\n// if the current editor is disabled\nreturn(\"html\"!==this.name||!g._parent.startAction)&&(\"function\"!=typeof this.$eval(\"disabled\")&&this.$eval(\"disabled\")||this.$eval(\"disabled()\")||\"html\"!==this.name&&this.$editor().showHtml||this.$parent.disabled||this.$editor().disabled)},displayActiveToolClass:function(a){return a?g.classes.toolbarButtonActive:\"\"},executeAction:e};angular.forEach(g.toolbar,function(a){\n// setup the toolbar group\nvar b=angular.element(\"<div>\");b.addClass(g.classes.toolbarGroup),angular.forEach(a,function(a){\n// init and add the tools to the group\n// a tool name (key name from taTools struct)\n//creates a child scope of the main angularText scope and then extends the childScope with the functions of this particular tool\n// reference to the scope and element kept\ng.tools[a]=angular.extend(g.$new(!0),d[a],k,{name:a}),g.tools[a].$element=j(d[a],g.tools[a]),\n// append the tool compiled with the childScope to the group element\nb.append(g.tools[a].$element)}),\n// append the group to the toolbar\nh.append(b)}),\n// update a tool\n// if a value is set to null, remove from the display\n// when forceNew is set to true it will ignore all previous settings, used to reset to taTools definition\n// to reset to defaults pass in taTools[key] as _newTool and forceNew as true, ie `updateToolDisplay(key, taTools[key], true);`\ng.updateToolDisplay=function(a,b,c){var d=g.tools[a];if(d){if(\n// get the last toolDefinition, then override with the new definition\nd._lastToolDefinition&&!c&&(b=angular.extend({},d._lastToolDefinition,b)),null===b.buttontext&&null===b.iconclass&&null===b.display)throw'textAngular Error: Tool Definition for updating \"'+a+'\" does not have a valid display/iconclass/buttontext value';\n// if tool is defined on this toolbar, update/redo the tool\nnull===b.buttontext&&delete b.buttontext,null===b.iconclass&&delete b.iconclass,null===b.display&&delete b.display;var e=j(b,d);d.$element.replaceWith(e),d.$element=e}},\n// we assume here that all values passed are valid and correct\ng.addTool=function(a,b,c,e){g.tools[a]=angular.extend(g.$new(!0),d[a],k,{name:a}),g.tools[a].$element=j(d[a],g.tools[a]);var f;void 0===c&&(c=g.toolbar.length-1),f=angular.element(h.children()[c]),void 0===e?(f.append(g.tools[a].$element),g.toolbar[c][g.toolbar[c].length-1]=a):(f.children().eq(e).after(g.tools[a].$element),g.toolbar[c][e]=a)},b.registerToolbar(g),g.$on(\"$destroy\",function(){b.unregisterToolbar(g.name)})}}}]),u.directive(\"textAngularVersion\",[\"textAngularManager\",function(a){var b=a.getVersion();return{restrict:\"EA\",link:function(a,c,d){c.html(b)}}}]),u.name});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/textangular/dist/textAngular.min.js\n// module id = 29\n// module chunks = 0","'use strict';\n\nrequire('./requires.js');\n\nvar angular = require('angular');\n\nangular.module(\"newsApp\",['textAngular']);\n\nrequire('./scripts/controllers/mainCtrl.js');\nrequire('./scripts/directives/ngMenus.js');\nrequire('./scripts/services/dataService.js');\nrequire('./scripts/services/authService.js');\n\n\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app.js\n// module id = 30\n// module chunks = 0"],"sourceRoot":""}